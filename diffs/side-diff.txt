diff -ryw '--width=260' '--exclude=README.*' ../src/branches.lisp ../src2/branches.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Support for various kinds of branches.											;;; Support for various kinds of branches.
;;; These constructs are not intended to appear in source code,									;;; These constructs are not intended to appear in source code,
;;; but are rather used to implement higher-level control-flow									;;; but are rather used to implement higher-level control-flow
;;; constructs.															;;; constructs.
;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Relatively high-level branch constructs.											;;; Relatively high-level branch constructs.

;; paired binary conditional switching branches.  The body in between the							;; paired binary conditional switching branches.  The body in between the
;; two branches must conserve the environment or else we won't have a								;; two branches must conserve the environment or else we won't have a
;; definite compile-time idea of the environment after the branch pair								;; definite compile-time idea of the environment after the branch pair
;; because we don't know whether the branch succeeds or fails at run-time							;; because we don't know whether the branch succeeds or fails at run-time
;; or not.  Note the vars must really be variables and not literals or								;; or not.  Note the vars must really be variables and not literals or
;; registers.															;; registers.
(defconstruct bcs-branch-pair (toplab (vara1 ~a vara2)										(defconstruct bcs-branch-pair (toplab (vara1 ~a vara2)
			       botlab (varb1 ~b varb2)													       botlab (varb1 ~b varb2)
			       &body body)														       &body body)
  `(;; All the variables involved need to be in registers before we start.							  `(;; All the variables involved need to be in registers before we start.
    (get-in-register ,vara1)													    (get-in-register ,vara1)
    (get-in-register ,vara2)													    (get-in-register ,vara2)
    (get-in-register ,varb1)													    (get-in-register ,varb1)
    (get-in-register ,varb2)													    (get-in-register ,varb2)
    (bcs-branch (,vara1 ,~a ,vara2) ,toplab ,botlab)										    (bcs-branch (,vara1 ,~a ,vara2) ,toplab ,botlab)
    ;; Since the vars were already in registers, BCS-BRANCH will not have							    ;; Since the vars were already in registers, BCS-BRANCH will not have
    ;; modified the environment after the branch point.										    ;; modified the environment after the branch point.
    (ensure-green ;Complain if the body doesn't clean up after itself. 								    (ensure-green ;Complain if the body doesn't clean up after itself. 
     ,@body)															     ,@body)
    ;; Due to the above GET-IN-REGISTERs and the ENSURE-GREEN, the b								    ;; Due to the above GET-IN-REGISTERs and the ENSURE-GREEN, the b
    ;; variables will already be in registers here, so this BCS-BRANCH will							    ;; variables will already be in registers here, so this BCS-BRANCH will
    ;; not need to modify the environment at all from the current one,								    ;; not need to modify the environment at all from the current one,
    ;; which is identical to the one just before the branch point.								    ;; which is identical to the one just before the branch point.
    (bcs-branch (,varb1 ,~b ,varb2) ,botlab ,toplab)))										    (bcs-branch (,varb1 ,~b ,varb2) ,botlab ,toplab)))
    																    
;; Twin (meaning with identical tests and variables) binary-operator								;; Twin (meaning with identical tests and variables) binary-operator
;; conditional switching branches.  The body in between the two									;; conditional switching branches.  The body in between the two
;; branches must conserve the environment or else we won't have a								;; branches must conserve the environment or else we won't have a
;; definite compile-time idea of the environment after the branch pair								;; definite compile-time idea of the environment after the branch pair
;; because we don't know whether the branch succeeds or fails at								;; because we don't know whether the branch succeeds or fails at
;; run-time or not.														;; run-time or not.
(defconstruct twin-bcs-branch ((exp1 ~ exp2) toplab botlab &body body)								(defconstruct twin-bcs-branch ((exp1 ~ exp2) toplab botlab &body body)
  (cond																  (cond
   ;; Relations that the instruction set supports directly.									   ;; Relations that the instruction set supports directly.
   ((member ~ *bc-branch-instructions*)												   ((member ~ *bc-branch-instructions*)
    `(_twin-bcs-branch ,exp1 ,~ ,exp2 ,toplab ,botlab ,@body))									    `(_twin-bcs-branch ,exp1 ,~ ,exp2 ,toplab ,botlab ,@body))

   ;; Relations we can convert to comparison with zero.										   ;; Relations we can convert to comparison with zero.
   ((member ~ '(> < >= <= = !=))												   ((member ~ '(> < >= <= = !=))
    `(_twin-bcs-branch (,exp1 - ,exp2) ,~ 0 ,toplab ,botlab ,@body))								    `(_twin-bcs-branch (,exp1 - ,exp2) ,~ 0 ,toplab ,botlab ,@body))
   (t																   (t
    (error "TWIN-BCS-BRANCH: Unknown relation ~s.~&" ~))))									    (error "TWIN-BCS-BRANCH: Unknown relation ~s.~&" ~))))

;; Like twin-bcs-branch, but with an uglier syntax that allows EXTRACT								;; Like twin-bcs-branch, but with an uglier syntax that allows EXTRACT
;; to be used.															;; to be used.
(defconstruct _twin-bcs-branch (exp1 ~ exp2 toplab botlab &body body)								(defconstruct _twin-bcs-branch (exp1 ~ exp2 toplab botlab &body body)
  (cond 															  (cond 
   ((and (register? exp1) (or (register? exp2) (zerop exp2)))									   ((and (register? exp1) (or (register? exp2) (zerop exp2)))
    ;; In this case we don't have to get the variables into registers.								    ;; In this case we don't have to get the variables into registers.
    `((bcs-branch (,exp1 ,~ ,exp2) ,toplab ,botlab)										    `((bcs-branch (,exp1 ,~ ,exp2) ,toplab ,botlab)
      ;; bcs-branch had better not itself change the environment								      ;; bcs-branch had better not itself change the environment
      ;; after it branches!													      ;; after it branches!
      (ensure-green														      (ensure-green
      ,@body)															      ,@body)
      (bcs-branch (,exp1 ,~ ,exp2) ,botlab ,toplab)))										      (bcs-branch (,exp1 ,~ ,exp2) ,botlab ,toplab)))
   ((and (variable? exp1) (or (variable? exp2) (zerop exp2)))									   ((and (variable? exp1) (or (variable? exp2) (zerop exp2)))
    `((get-in-register ,exp1)													    `((get-in-register ,exp1)
      (get-in-register ,exp2)													      (get-in-register ,exp2)
      (bcs-branch (,exp1 ,~ ,exp2) ,toplab ,botlab)										      (bcs-branch (,exp1 ,~ ,exp2) ,toplab ,botlab)
      ;; bcs-branch had better not itself change the environment								      ;; bcs-branch had better not itself change the environment
      ;; after it branches!													      ;; after it branches!
      (ensure-green														      (ensure-green
       ,@body)															       ,@body)
      (bcs-branch (,exp1 ,~ ,exp2) ,botlab ,toplab)))										      (bcs-branch (,exp1 ,~ ,exp2) ,botlab ,toplab)))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms '(1 3)))))													     :relevant-terms '(1 3)))))

;; Twin unconditional switching branches.											;; Twin unconditional switching branches.
;; Now that the environment contains information other than									;; Now that the environment contains information other than
;; the locations of run-time variables, does it make										;; the locations of run-time variables, does it make
;; sense for it to be completely green?  Declaring static variables								;; sense for it to be completely green?  Declaring static variables
;; inside the body might be expected to be able to affect the									;; inside the body might be expected to be able to affect the
;; outside world.  Or, maybe it shouldn't.  Haven't decided yet.								;; outside world.  Or, maybe it shouldn't.  Haven't decided yet.
(defconstruct twin-us-branch (toplab botlab &body body)										(defconstruct twin-us-branch (toplab botlab &body body)
  ;; TWIN-US-BRANCH is GREEN on the outside because encountering it from							  ;; TWIN-US-BRANCH is GREEN on the outside because encountering it from
  ;; the outside you just jump over it, and the environment doesn't change.							  ;; the outside you just jump over it, and the environment doesn't change.
  `(declare-green														  `(declare-green
    (sbra-pair ,toplab ,botlab . ,body))											    (sbra-pair ,toplab ,botlab . ,body))
  ;; We have no idea what the environment is inside the first bra, though							  ;; We have no idea what the environment is inside the first bra, though
  ;; (cuz we might slip into the middle as a subroutine call), so we can't							  ;; (cuz we might slip into the middle as a subroutine call), so we can't
  ;; put an ensure-green or anything in there.  The environment in effect							  ;; put an ensure-green or anything in there.  The environment in effect
  ;; at this point, which just leeches in from above, is usually wrong.								  ;; at this point, which just leeches in from above, is usually wrong.
  ;; Still, the body needs to be careful that whatever environment is in							  ;; Still, the body needs to be careful that whatever environment is in
  ;; effect at its end is the same as the one it assumes at its top.  But							  ;; effect at its end is the same as the one it assumes at its top.  But
  ;; this is a job for a higher level to worry about.										  ;; this is a job for a higher level to worry about.
  )																  )

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; lower-level branch constructs.												;;; lower-level branch constructs.

;;; Note to self: I think that the way branches and environments								;;; Note to self: I think that the way branches and environments
;;; interact may be incorrect.  If the variables mentioned in the								;;; interact may be incorrect.  If the variables mentioned in the
;;; branch are not in registers, then the environment needs to change								;;; branch are not in registers, then the environment needs to change
;;; to allow the branch to be done---so the environment declared								;;; to allow the branch to be done---so the environment declared
;;; at the place we're branching to may be wrong.  Need to go thru								;;; at the place we're branching to may be wrong.  Need to go thru
;;; and fix carefully.  Really, need a more sophisticated approach								;;; and fix carefully.  Really, need a more sophisticated approach
;;; to how environments are kept track of during compilation of									;;; to how environments are kept track of during compilation of
;;; complex control-flow structures.												;;; complex control-flow structures.

;; This low-level thing doesn't worry about environments at all.								;; This low-level thing doesn't worry about environments at all.
;; That's a job for higher-level dudes that use it.										;; That's a job for higher-level dudes that use it.
(defconstruct sbra-pair (toplab botlab &body body)										(defconstruct sbra-pair (toplab botlab &body body)
  `((sbra ,toplab ,botlab)													  `((sbra ,toplab ,botlab)
    ,@body															    ,@body
    (sbra ,botlab ,toplab)))													    (sbra ,botlab ,toplab)))

;; 																;; 
;; SBRA: Switching branch (unconditional).  Branch is										;; SBRA: Switching branch (unconditional).  Branch is
;; from label thislab to otherlab.												;; from label thislab to otherlab.
;;																;;
;; Semantics is: if we branch to this statement from										;; Semantics is: if we branch to this statement from
;; otherlab, then continue forwards normally.  If we										;; otherlab, then continue forwards normally.  If we
;; arrive at this statement normally, then branch to										;; arrive at this statement normally, then branch to
;; otherlab.  If we arrive at this statement some other										;; otherlab.  If we arrive at this statement some other
;; way, results are undefined.													;; way, results are undefined.
;; 																;; 
(defconstruct sbra (thislab otherlab)												(defconstruct sbra (thislab otherlab)
  `((label ,thislab)  ;Convention: label precedes labeled statement.								  `((label ,thislab)  ;Convention: label precedes labeled statement.
    (bra ,otherlab))) ;Assume that the hardware gives the semantics we want.							    (bra ,otherlab))) ;Assume that the hardware gives the semantics we want.

(defconstruct sbez (thislab var lab)												(defconstruct sbez (thislab var lab)
  ;; There's no built-in BEZ, so we reserve reg $0 to be zero									  ;; There's no built-in BEZ, so we reserve reg $0 to be zero
  ;; so we can just use BEQ instead.												  ;; so we can just use BEQ instead.
  `(bcs-branch (,var = (reg 0)) ,thislab ,lab))											  `(bcs-branch (,var = (reg 0)) ,thislab ,lab))

(defconstruct sbnz (thislab var lab)												(defconstruct sbnz (thislab var lab)
  ;; There's no built-in BNZ, so we reserve reg $0 to be zero									  ;; There's no built-in BNZ, so we reserve reg $0 to be zero
  ;; so we can just use BNE instead.												  ;; so we can just use BNE instead.
  `(bcs-branch (,var != (reg 0)) ,thislab ,lab))										  `(bcs-branch (,var != (reg 0)) ,thislab ,lab))

(defconstruct bcs-branch ((var1 ~ var2) thislab otherlab)									(defconstruct bcs-branch ((var1 ~ var2) thislab otherlab)
  (cond																  (cond
   ;; If the variables aren't in registers, get them there.  The only thing							   ;; If the variables aren't in registers, get them there.  The only thing
   ;; is, I'm not sure it makes sense to do any environment manipulation at							   ;; is, I'm not sure it makes sense to do any environment manipulation at
   ;; this level because it makes it difficult for the higher level stuff							   ;; this level because it makes it difficult for the higher level stuff
   ;; to ensure thtat the environment is consistent at both ends of the								   ;; to ensure thtat the environment is consistent at both ends of the
   ;; actual branch point.													   ;; actual branch point.
   ((and (member ~ '(= !=)) (numberp var2) (zerop var2))									   ((and (member ~ '(= !=)) (numberp var2) (zerop var2))
    ;; To compare for equality with zero, compare with $0 (reserved for 0).							    ;; To compare for equality with zero, compare with $0 (reserved for 0).
    `(bcs-branch (,var1 ,~ (reg 0)) ,thislab ,otherlab))									    `(bcs-branch (,var1 ,~ (reg 0)) ,thislab ,otherlab))
   ((and (or (register? var1)													   ((and (or (register? var1)
	     (in-register? var1 env)													     (in-register? var1 env)
	     (eql var1 0))														     (eql var1 0))
	 (or (register? var2)														 (or (register? var2)
	     (in-register? var2 env)													     (in-register? var2 env)
	     (eql var2 0)))														     (eql var2 0)))
    `((label ,thislab)														    `((label ,thislab)
      ;; This assumes that BC-BRANCH has the right switching sort of								      ;; This assumes that BC-BRANCH has the right switching sort of
      ;; semantics, and that it doesn't insert any instructions before the							      ;; semantics, and that it doesn't insert any instructions before the
      ;; actual branch.														      ;; actual branch.
      (bc-branch (,var1 ,~ ,var2) ,otherlab)))											      (bc-branch (,var1 ,~ ,var2) ,otherlab)))
   ;; Does this make sense?													   ;; Does this make sense?
   ((and (symbolp var1) (defined-in-env? var1 env)										   ((and (symbolp var1) (defined-in-env? var1 env)
	 (not (in-register? var1 env)))													 (not (in-register? var1 env)))
    `((get-in-register ,var1)													    `((get-in-register ,var1)
      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))									      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))
   ((and (symbolp var2) (defined-in-env? var2 env)										   ((and (symbolp var2) (defined-in-env? var2 env)
	 (not (in-register? var2 env)))													 (not (in-register? var2 env)))
    `((get-in-register ,var2)													    `((get-in-register ,var2)
      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))									      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))
   ((and (symbolp var1) (not (defined-in-env? var1 env)))									   ((and (symbolp var1) (not (defined-in-env? var1 env)))
    `((add-to-env ,var1)													    `((add-to-env ,var1)
      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))									      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))
   ((and (symbolp var2) (not (defined-in-env? var2 env)))									   ((and (symbolp var2) (not (defined-in-env? var2 env)))
    `((add-to-env ,var2)													    `((add-to-env ,var2)
      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))									      (bcs-branch (,var1 ,~ ,var2) ,thislab ,otherlab)))
   ;; I could go on and handle expressions and literals as well, but again							   ;; I could go on and handle expressions and literals as well, but again
   ;; I'm concerned that this isn't the right level.										   ;; I'm concerned that this isn't the right level.
   ))																   ))
   																   
;; binary conditional branch													;; binary conditional branch
(defconstruct bc-branch ((var1 ~ var2) destlab)											(defconstruct bc-branch ((var1 ~ var2) destlab)
  (cond																  (cond
   ((and (or (register? var1) (eql var1 0))											   ((and (or (register? var1) (eql var1 0))
	 (or (register? var2) (eql var2 0)))												 (or (register? var2) (eql var2 0)))
    `(rbc-branch (,var1 ,~ ,var2) ,destlab))											    `(rbc-branch (,var1 ,~ ,var2) ,destlab))
   ;; If the variables are in registers, just look at the registers.								   ;; If the variables are in registers, just look at the registers.
   ((and (symbolp var1) (in-register? var1 env))										   ((and (symbolp var1) (in-register? var1 env))
    `(bc-branch (,(location var1 env) ,~ ,var2) ,destlab))									    `(bc-branch (,(location var1 env) ,~ ,var2) ,destlab))
   ((and (symbolp var2) (in-register? var2 env))										   ((and (symbolp var2) (in-register? var2 env))
    `(bc-branch (,var1 ,~ ,(location var2 env)) ,destlab))									    `(bc-branch (,var1 ,~ ,(location var2 env)) ,destlab))
   ;; We can't really do any environment manipulation at this level								   ;; We can't really do any environment manipulation at this level
   ;; because the instructions manipulated will come between us and the								   ;; because the instructions manipulated will come between us and the
   ;; label inserted by BCS-BRANCH.												   ;; label inserted by BCS-BRANCH.
   (t																   (t
    (error "BC-BRANCH can only cope with variables residing in registers!")							    (error "BC-BRANCH can only cope with variables residing in registers!")
    )))																    )))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Branching primitives.													;;; Branching primitives.

;; A label is a tag that gives an address in code that is a target								;; A label is a tag that gives an address in code that is a target
;; for branching.														;; for branching.
(defconstruct label (labname)													(defconstruct label (labname)
  labname)															  labname)

(defconstruct bez (reg lab)													(defconstruct bez (reg lab)
  ;; There's no built-in BEZ, so we reserve reg $0 to be zero									  ;; There's no built-in BEZ, so we reserve reg $0 to be zero
  ;; so we can just use BEQ instead.												  ;; so we can just use BEQ instead.
  `(rbc-branch (,reg = (reg 0)) ,lab))												  `(rbc-branch (,reg = (reg 0)) ,lab))

(defconstruct bnz (reg lab)													(defconstruct bnz (reg lab)
  ;; Similar, use BNE.														  ;; Similar, use BNE.
  `(rbc-branch (,reg != (reg 0)) ,lab))												  `(rbc-branch (,reg != (reg 0)) ,lab))

;; Binary conditional branch operator symbols.											;; Binary conditional branch operator symbols.
(defparameter *bc-branch-instructions*												(defparameter *bc-branch-instructions*
  '((!= . bne) (= . beq)))													  '((!= . bne) (= . beq)))

(defparameter *zerocmp-branch-instructions*											(defparameter *zerocmp-branch-instructions*
  '((>= . bgez) (<= . blez) (> . bgtz) (< . bltz)))										  '((>= . bgez) (<= . blez) (> . bgtz) (< . bltz)))

;; "register binary conditional branch"												;; "register binary conditional branch"
;; tests whether two registers satisfy some relation ~ and if so								;; tests whether two registers satisfy some relation ~ and if so
;; branch to DESTLAB.														;; branch to DESTLAB.
(defconstruct rbc-branch ((reg1 ~ reg2) destlab)										(defconstruct rbc-branch ((reg1 ~ reg2) destlab)
  (cond																  (cond
   ((assoc ~ *bc-branch-instructions*)												   ((assoc ~ *bc-branch-instructions*)
    `(,(cdr (assoc ~ *bc-branch-instructions*))											    `(,(cdr (assoc ~ *bc-branch-instructions*))
      ,reg1 ,reg2 ,destlab))													      ,reg1 ,reg2 ,destlab))
   ((and (eql reg2 0)														   ((and (eql reg2 0)
	 (assoc ~ *zerocmp-branch-instructions*))											 (assoc ~ *zerocmp-branch-instructions*))
    `(,(cdr (assoc ~ *zerocmp-branch-instructions*))										    `(,(cdr (assoc ~ *zerocmp-branch-instructions*))
      ,reg1 ,destlab))														      ,reg1 ,destlab))
   (t																   (t
    ;; No built-in instruction to compare the two registers.									    ;; No built-in instruction to compare the two registers.
    ;; We have to subtract & compare with zero instead.										    ;; We have to subtract & compare with zero instead.
    (error "Can't RBC-BRANCH with ~s operator.~&" ~)										    (error "Can't RBC-BRANCH with ~s operator.~&" ~)
    )))																    )))
diff -ryw '--width=260' '--exclude=README.*' ../src/clike.lisp ../src2/clike.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; C-like assignment statements.												;;; C-like assignment statements.

(definfix (var ++) :opposite --													(definfix (var ++) :opposite --
  `(,var += 1))															  `(,var += 1))

(definfix (var --) :opposite ++													(definfix (var --) :opposite ++
  `(,var -= 1))															  `(,var -= 1))

;; "-" statement: negate the given lvalue in place.										;; "-" statement: negate the given lvalue in place.
(defconstruct - (var)														(defconstruct - (var)
  (cond																  (cond
   ((register? var)														   ((register? var)
    `(neg ,var))														    `(neg ,var))
   (t																   (t
    (extract form env :lvalues 1))))												    (extract form env :lvalues 1))))

(definfix (var <=< val)														(definfix (var <=< val)
  (cond																  (cond
   ((and (numberp val) (zerop val))												   ((and (numberp val) (zerop val))
    '())															    '())
   ((and (register? var) (static-val-addr? val env))										   ((and (register? var) (static-val-addr? val env))
    `(rl ,var ,(second val)))													    `(rl ,var ,(second val)))
   ((and (register? var) (literal? val env))											   ((and (register? var) (literal? val env))
    `(rl ,var ,val))														    `(rl ,var ,val))
   ((and (register? var) (register? val))											   ((and (register? var) (register? val))
    `(rlv ,var ,val))														    `(rlv ,var ,val))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms (if (not (literal? val env)) '(2))										     :relevant-terms (if (not (literal? val env)) '(2))
	     :lvalues 1))))														     :lvalues 1))))

(definfix (var >=> val)														(definfix (var >=> val)
  (cond																  (cond
   ((and (numberp val) (zerop val))												   ((and (numberp val) (zerop val))
    '())															    '())
   ((and (register? var) (static-val-addr? val env))										   ((and (register? var) (static-val-addr? val env))
    `(rr ,var ,(second val)))													    `(rr ,var ,(second val)))
   ((and (register? var) (literal? val env))											   ((and (register? var) (literal? val env))
    `(rr ,var ,val))														    `(rr ,var ,val))
   ((and (register? var) (register? val))											   ((and (register? var) (register? val))
    `(rrv ,var ,val))														    `(rrv ,var ,val))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms (if (not (literal? val env)) '(2))										     :relevant-terms (if (not (literal? val env)) '(2))
	     :lvalues 1))))														     :lvalues 1))))

(definfix (var += val) :opposite -=												(definfix (var += val) :opposite -=
  (cond																  (cond
   ((and (numberp val) (zerop val))												   ((and (numberp val) (zerop val))
    '()) ;Optimization: don't add 0												    '()) ;Optimization: don't add 0
   ((and (register? var) (static-val-addr? val env))										   ((and (register? var) (static-val-addr? val env))
    `(addi ,var ,(second val)))													    `(addi ,var ,(second val)))
   ((and (register? var) (literal? val env))											   ((and (register? var) (literal? val env))
    `(addi ,var ,val))														    `(addi ,var ,val))
   ((and (register? var) (register? val))											   ((and (register? var) (register? val))
    `(add ,var ,val))														    `(add ,var ,val))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms (if (not (literal? val env)) '(2))										     :relevant-terms (if (not (literal? val env)) '(2))
	     :lvalues 1))))														     :lvalues 1))))
    																    
(definfix (var -= val) :opposite +=												(definfix (var -= val) :opposite +=
  (cond																  (cond
   ((and (register? var) (numberp val))												   ((and (register? var) (numberp val))
    `(,var += ,(- val)))		;No SUBI instruction.									    `(,var += ,(- val)))		;No SUBI instruction.
   ((and (register? var) (static-array? val env))										   ((and (register? var) (static-array? val env))
    `(,var += ,(intern (concatenate 'string "-" (symbol-name val)))))								    `(,var += ,(intern (concatenate 'string "-" (symbol-name val)))))
   ((and (register? var) (static-val-addr? val env))										   ((and (register? var) (static-val-addr? val env))
    `(addi ,var ,(intern (concatenate 'string "-"									      |	    `(addi ,var ,(intern (concatenate 'string "-" (symbol-name (second val))))))
				      (symbol-name (second val))))))							      <
   ((and (register? var)													   ((and (register? var)
	 (literal? val env)														 (literal? val env)
	 (negated-sym? val))														 (negated-sym? val))
    `(,var += ,(positive-of val)))												    `(,var += ,(positive-of val)))
   ((and (register? var) (register? val))											   ((and (register? var) (register? val))
    `(sub ,var ,val))														    `(sub ,var ,val))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms (if (not (literal? val env)) '(2))										     :relevant-terms (if (not (literal? val env)) '(2))
	     :lvalues 1))))														     :lvalues 1))))

;; Very much like +=.  More abstraction?											;; Very much like +=.  More abstraction?
(definfix (var ^= val)														(definfix (var ^= val)
  (cond																  (cond
   ((and (numberp val) (zerop val))												   ((and (numberp val) (zerop val))
    '()) ;Optimization: don't add 0												    '()) ;Optimization: don't add 0
   ((and (register? var) (numberp val))												   ((and (register? var) (numberp val))
    `(xori ,var ,val))														    `(xori ,var ,val))
   ((and (register? var) (register? val))											   ((and (register? var) (register? val))
    `(xor ,var ,val))														    `(xor ,var ,val))
   (t																   (t
    (extract form env														    (extract form env
	     :relevant-terms (if (not (numberp val)) '(2))										     :relevant-terms (if (not (numberp val)) '(2))
	     :lvalues 1))))														     :lvalues 1))))

(definfix (dest ^=& src1 src2)													(definfix (dest ^=& src1 src2)
  (cond																  (cond
   ((and (register? dest) (register? src1) (register? src2))									   ((and (register? dest) (register? src1) (register? src2))
    `(andx ,dest ,src1 ,src2))													    `(andx ,dest ,src1 ,src2))
   (t																   (t
    (extract form env :lvalues 1))))												    (extract form env :lvalues 1))))

(definfix (dest ^=<< src1 src2)													(definfix (dest ^=<< src1 src2)
  (cond																  (cond
   ((and (register? dest) (register? src1) (register? src2))									   ((and (register? dest) (register? src1) (register? src2))
    `(sllvx ,dest ,src1 ,src2))													    `(sllvx ,dest ,src1 ,src2))
   (t																   (t
    (extract form env :lvalues 1))))												    (extract form env :lvalues 1))))

;; This is a logical shift right.												;; This is a logical shift right.
(definfix (dest ^=>> src1 src2)													(definfix (dest ^=>> src1 src2)
  (cond																  (cond
   ((and (register? dest) (register? src1) (register? src2))									   ((and (register? dest) (register? src1) (register? src2))
    `(srlvx ,dest ,src1 ,src2))													    `(srlvx ,dest ,src1 ,src2))
   (t																   (t
    (extract form env :lvalues 1))))												    (extract form env :lvalues 1))))

;; (base _ offset) gets transformed into this, where dest is									;; (base _ offset) gets transformed into this, where dest is
;; some temporary register.													;; some temporary register.
(definfix (dest <->_ base offset)												(definfix (dest <->_ base offset)
  ;; THIS IS WRONG!  Extracting before expanding runs the danger								  ;; THIS IS WRONG!  Extracting before expanding runs the danger
  ;; that the variable assignments used during the extraction									  ;; that the variable assignments used during the extraction
  ;; could be invalidated during the body of the WITH, I think 6/3/97								  ;; could be invalidated during the body of the WITH, I think 6/3/97
  (or (extract form env :lvalues 1)												  (or (extract form env :lvalues 1)
      `(with (,base += ,offset)													      `(with (,base += ,offset)
	  (,dest <->* ,base))))														  (,dest <->* ,base))))
    																    
(definfix (dest <-_ base offset) :opposite ->_											(definfix (dest <-_ base offset) :opposite ->_
  `(,dest <-* (,base + ,offset)))												  `(,dest <-* (,base + ,offset)))

(definfix (dest ->_ base offset) :opposite <-_											(definfix (dest ->_ base offset) :opposite <-_
  `(,dest ->* (,base + ,offset)))												  `(,dest ->* (,base + ,offset)))

(definfix (dest <-* ptr)													(definfix (dest <-* ptr)
  ;; THIS IS WRONG!  Extracting before expanding runs the danger								  ;; THIS IS WRONG!  Extracting before expanding runs the danger
  ;; that the variable assignments used during the extraction									  ;; that the variable assignments used during the extraction
  ;; could be invalidated during the header of the LET.										  ;; could be invalidated during the header of the LET.
  (or																  (or
   (extract form env :lvalues 1)												   (extract form env :lvalues 1)
   (let ((tv (gentemp)))													   (let ((tv (gentemp)))
     `(let (,tv <->* ,ptr)													     `(let (,tv <->* ,ptr)
	(,dest <- ,tv)))))														(,dest <- ,tv)))))
	 																 
(definfix (dest ->* ptr)													(definfix (dest ->* ptr)
  (or																  (or
   (extract form env :lvalues 1)												   (extract form env :lvalues 1)
   (let ((tv (gentemp)))													   (let ((tv (gentemp)))
     `(let (,tv <->* ,ptr)													     `(let (,tv <->* ,ptr)
	(,dest -> ,tv)))))														(,dest -> ,tv)))))
	 																 
(definfix (left <->* rightptr)													(definfix (left <->* rightptr)
  (cond																  (cond
   ((extract form env :lvalues 1))												   ((extract form env :lvalues 1))
   ((and (register? left) (register? rightptr))											   ((and (register? left) (register? rightptr))
    `(exch ,left ,rightptr))))													    `(exch ,left ,rightptr))))

(definfix (var +=* val1 val2) :opposite -=*											(definfix (var +=* val1 val2) :opposite -=*
  `(call mult ,var ,val1 ,val2))												  `(call mult ,var ,val1 ,val2))

(definfix (var -=* val1 val2) :opposite +=*											(definfix (var -=* val1 val2) :opposite +=*
  `(rcall mult ,var ,val1 ,val2))												  `(rcall mult ,var ,val1 ,val2))

(definfix (var +=*/ val1 val2) :opposite -=*/											(definfix (var +=*/ val1 val2) :opposite -=*/
  `(call _smf ,val1 ,val2 ,var)) ;Note dest is last.										  `(call _smf ,val1 ,val2 ,var)) ;Note dest is last.

(definfix (var -=*/ val1 val2) :opposite +=*/											(definfix (var -=*/ val1 val2) :opposite +=*/
  `(rcall _smf ,val1 ,val2 ,var))												  `(rcall _smf ,val1 ,val2 ,var))

(definfix (left <-> right)													(definfix (left <-> right)
  (cond																  (cond
   ((and (listp right) (eq (car right) '*))											   ((and (listp right) (eq (car right) '*))
    `(,left <->* ,(cadr right)))												    `(,left <->* ,(cadr right)))
   ((and (location? left) (location? right))											   ((and (location? left) (location? right))
    `(swaploc ,left ,right))													    `(swaploc ,left ,right))
   ((and (listp right)														   ((and (listp right)
	 (>= (length right) 3)														 (>= (length right) 3)
	 (dbind (base ~ offset) right													 (dbind (base ~ offset) right
	   (if (eq ~ '_)														   (if (eq ~ '_)
	       `(,left <->_ ,base ,offset)))))												       `(,left <->_ ,base ,offset)))))
   ((and (listp left)														   ((and (listp left)
	 (>= (length left) 3)														 (>= (length left) 3)
	 (dbind (base ~ offset) left													 (dbind (base ~ offset) left
	   (if (eq ~ '_)														   (if (eq ~ '_)
	       `(,right <->_ ,base ,offset)))))												       `(,right <->_ ,base ,offset)))))
   ((extract form env :lvalues '(1 2)))))											   ((extract form env :lvalues '(1 2)))))

(defun << (a b)															(defun << (a b)
  (ash a b))															  (ash a b))
diff -ryw '--width=260' '--exclude=README.*' ../src/controlflow.lisp ../src2/controlflow.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;; ----------------------------------------------------------------------							;;; ----------------------------------------------------------------------
;;; High-level control flow constructs suitable for user use.									;;; High-level control flow constructs suitable for user use.

;; if CONDEXPR then														;; if CONDEXPR then
;;    BODY...															;;    BODY...
;; [else BODY2...]														;; [else BODY2...]
;;																;;
;; CONDEXPR is evaluated; if result is nonzero body is executed.  In either							;; CONDEXPR is evaluated; if result is nonzero body is executed.  In either
;; case, CONDEXPR is then evaluated in reverse.  The value should be the							;; case, CONDEXPR is then evaluated in reverse.  The value should be the
;; same whether or not BODY was executed, or else behavior undefined.								;; same whether or not BODY was executed, or else behavior undefined.

;; NOTE 6/26/97: IF and all its subsidiary branching constructs need to be							;; NOTE 6/26/97: IF and all its subsidiary branching constructs need to be
;; completely cleaned up and reorganized.  One big thing is that code for							;; completely cleaned up and reorganized.  One big thing is that code for
;; computing EXPR in a condition expression of a form like (EXPR > 0) needs							;; computing EXPR in a condition expression of a form like (EXPR > 0) needs
;; to be wrapped around the entire IF.  And things like (EXPR1 > EXPR2)								;; to be wrapped around the entire IF.  And things like (EXPR1 > EXPR2)
;; need to be transformed into ((EXPR1 - EXPR2) > 0).										;; need to be transformed into ((EXPR1 - EXPR2) > 0).

															      >
															      >	#| old version of IF
(defconstruct if (condexpr then &body body)											(defconstruct if (condexpr then &body body)
  ;; If the user forgets the word THEN, be nice to him, and figure out what he meant.						  ;; If the user forgets the word THEN, be nice to him, and figure out what he meant.
  (if (not (eq then 'then))													  (if (not (eq then 'then))
      (setq body (cons then body)))												      (setq body (cons then body)))

  (cond																  (cond
   ;; If there's an "else" clause, dispatch to the lower-level "ifelse" construct.						   ;; If there's an "else" clause, dispatch to the lower-level "ifelse" construct.

   ((member 'else body)														   ((member 'else body)
    (let ((ifpart (subseq body 0 (position 'else body)))									    (let ((ifpart (subseq body 0 (position 'else body)))
	  (elsepart (subseq body (1+ (position 'else body)))))										  (elsepart (subseq body (1+ (position 'else body)))))
      `(ifelse ,condexpr ,ifpart ,elsepart)))											      `(ifelse ,condexpr ,ifpart ,elsepart)))

   ;; If the condition is a relational expression, dispatch to the								   ;; If the condition is a relational expression, dispatch to the
   ;; lower-level "_if" construct which assumes this.										   ;; lower-level "_if" construct which assumes this.

   ((and (listp condexpr)													   ((and (listp condexpr)
	 (null (cdddr condexpr))													 (null (cdddr condexpr))
	 (member (second condexpr) '(= != > <= < >=)))											 (member (second condexpr) '(= != > <= < >=)))
    `(_if ,condexpr then . ,body))												    `(_if ,condexpr then . ,body))

   ;; For any other kinds of expressions, we don't know any shortcuts; just							   ;; For any other kinds of expressions, we don't know any shortcuts; just
   ;; see if the expression evaluates to nonzero.										   ;; see if the expression evaluates to nonzero.
   (t																   (t
    ;; The current version is appropriate only for testing an arbitrary								    ;; The current version is appropriate only for testing an arbitrary
    ;; value to see if it is non-zero.  For other kinds of conditions,								    ;; value to see if it is non-zero.  For other kinds of conditions,
    ;; other implementations would be more appropriate.										    ;; other implementations would be more appropriate.
    (if (symbolp condexpr)													    (if (symbolp condexpr)
	`(_if (,condexpr != 0) then . ,body)												`(_if (,condexpr != 0) then . ,body)
      (let ((tv (gentemp)))													      (let ((tv (gentemp)))
	`(let (,tv <- ,condexpr)													`(let (,tv <- ,condexpr)
	   (_if (,tv != 0) then . ,body)))))))												   (_if (,tv != 0) then . ,body)))))))
															      >	|#

#|															      |	;;; New version of IF
															      >	(defconstruct if (condexpr then &body body)
																  
;;; New version of IF, in progress											      |	  (let (thenpart elsepart)
																    
(defconstruct if (condexpr then &body body)										      |	    ;; extract then and else parts from body
  ;; Some special things to worry about:										      |	    (cond ((member 'else body)
  ;; ! && || >= <= > <													      |	           (setq thenpart (subseq body 0 (position 'else body)))
															      >	           (setq elsepart (subseq body (1+ (position 'else body)))) )
															      >	          
															      >	          (t
															      >	           (setq thenpart body)
															      >	           (setq elsepart nil) ))
															      >	    
															      >	    ;; break down the conditional expression
  (cond																    (cond
   ;; If condition expression is literal zero, just execute the								      |	          ;; If expression is literal zero, execute the ELSE part only (if any).
   ;; ELSE part (if any).												      |	          ((and (= (length condexpr) 1)
   ((zerop condexpr)													      |	               (numberp (first condexpr))
    (if (member 'else body)												      |	               (zerop (first condexpr)))
	(subseq body (1+ (position 'else body)))))									      |	           elsepart)
															      |
   ;; Literal number (other than zero): Execute THEN part only.								      |	          ;; If expression is literal number (other than zero), execute THEN part only.
   ((numberp condexpr)													      |	          ((and (= (length condexpr) 1)
    (if (member 'else body)												      |	                (numberp (first condexpr)))
	(subseq body 0 (position 'else body))										      |	           thenpart)
      body))														      |
															      |	          ;; If expression is single variable, compare it to zero.
   ;; Variable: Compare it to zero, dude!										      |	          ((and (= (length condexpr) 1)
   ((variable? condexpr)												      |	                (variable? (car condexpr)))
    `(if (,condexpr != 0) then ,body))											      |	           `(if (,(car condexpr) != 0) then . ,body) )

   ;; Logical negation: A separate construct handles this.								      |	          ;; If expression is logical negation, test for equality with zero.
   ((ifmatch condexpr (! expr)													          ((ifmatch condexpr (! expr)
       `(ifnot ,expr . ,body)))												      |	           `(if (,expr = 0) then . ,body) ))

   ;; Various binary operations/relations:										      |	          ;; Handle binary operations and relations:
   ((ifmatch condexpr (exp1 ~ exp2)												          ((ifmatch condexpr (exp1 ~ exp2)
															      >	             
       (cond															           (cond
	;; Shortcutting AND is easy: Nested IFs.									      |	                 ;; Shortcut AND expression by nesting IFs.
	((eq ~ '&&)														                 ((eq ~ '&&)
	 `(if ,exp1 then (if ,exp2 then . ,body)))										                  `(if ,exp1 then (if ,exp2 then . ,body)) )

	;; Shortcutting OR efficiently is a little more tricky.									                 ;; Shortcutting OR efficiently is a little more tricky.
															      >	                 ;; NOTE: This method is not very efficient. If the expression
															      >	                 ;; on the left of the OR is true, the expression on the right is
															      >	                 ;; not evaluated, which maintains the proper semantics. However,
															      >	                 ;; the code in the then part is reproduced in the output twice.
	((eq ~ '||)														                 ((eq ~ '||)
	 (let ((tv (gentemp))												      |	                  `(if ,exp1 then
	       (bi (gentemp "_IF_OR_BEFORE_IN"))									      |	                     ,thenpart
	       (bo (gentemp "_IF_OR_BEFORE_OUT"))									      |	                   else 
															      >	                     (if ,exp2 then
															      >	                       ,thenpart
															      >	                     else
															      >	                       ,elsepart
															      >	                     )
															      >	                   )
															      >	                  )
															      >	                  
															      >	                  #| other attempts at implementing OR that don't quite work
															      >	                  `(let (tmpif <- 0)
															      >	                     (if ,exp1 then
															      >	                       (tmpif += 1)
															      >	                     else
															      >	                       (if ,exp2 then
															      >	                         (tmpif += 1) )
															      >	                     )
															      >	                     (if (tmpif) then
															      >	                       ,thenpart
															      >	                     else
															      >	                       ,elsepart
															      >	                     )
															      >	                     (if (tmpif) then
															      >	                       (tmpif -= 1) )
															      >	                   )
															      >	                  )
															      >	                  
															      >	                  (let ((bi (gentemp "_IF_OR_BIN"))
															      >	                        (bo (gentemp "_IF_OR_BOUT")) )
															      >	                    `((if ,exp1 then
															      >	                        (go to ,bi from ,bo))
															      >	                      (if ,exp2 then
															      >	                        (if ,exp1 then
															      >	                          (come from ,bo to ,bi))
															      >	                        ,.body)) ))
															      >	                     
															      >	                    (tv (gentemp))
	       (ai (gentemp "_IF_OR_AFTER_IN"))											                    (ai (gentemp "_IF_OR_AFTER_IN"))
	       (ao (gentemp "_IF_OR_AFTER_OUT")))									      |	                    (ao (gentemp "_IF_OR_AFTER_OUT"))
	   `(with (,tv <- ,exp1)												                    `(with (,tv <- ,exp1)
		  (if ,tv then (go to ,bi from ,bo))										                       (if ,tv then (go to ,bi from ,bo))
		  (if ,exp2 then												                       (if ,exp2 then
		      (if ,tv then (come from ,bo to ,bi))									                         (if ,tv then (come from ,bo to ,bi))
		      ,@body												      |	                         ,.body
		      (if ,tv then (go to ,ao from ,ai)))									                         (if ,tv then (go to ,ao from ,ai)) )
		  (if ,tv then (come from ,ai to ,ao)))))									                       (if ,tv then (come from ,ai to ,ao)) )))
															      >	                    |#
															      >	            
																                    
															      >	                 ;; Relation where second expression is not literal zero,
															      >	                 ;; rearrage expression to create comparison with zero.
	((and (member ~ '(>= <= > <))												                 ((and (member ~ '(>= <= > <))
	      (not (zerop exp2)))											      |	                       (not (and (numberp exp2)
															      >	                                 (zerop exp2) )))
	 `(if ((,exp1 - ,exp2) ,~ 0) then . ,body))										                  `(if ((,exp1 - ,exp2) ,~ 0) then . ,body) )
	(t `(if (,exp1 != 0) then . ,body))										      <
																     
															      >	                 ;; Relational or equality operation can't be broken down further,
															      >	                 ;; transform to middle-level contructs
															      >	                 ((member ~ '(= != >= <= > <))
															      >	                  (if (null elsepart)
															      >	                    `(_if ,condexpr then . ,body)
															      >	                    `(_ifelse ,condexpr ,thenpart ,elsepart) ))
	     															     
															      >	                 ;(t `(if (,exp1 != 0) then . ,body))
															      >	          )))
  )																    )
|#															      |	  )
															      >	)
															      >

;; for VAR = START to END													;; for VAR = START to END
;;    BODY...															;;    BODY...
;;																;;
;; Semantics: START and END are expressions.  They are each evaluated once							;; Semantics: START and END are expressions.  They are each evaluated once
;; forwards at the beginning of the loop, and once in reverse at the end of							;; forwards at the beginning of the loop, and once in reverse at the end of
;; the loop.  They should return the same value both times.									;; the loop.  They should return the same value both times.
;;																;;
;; VAR is a fresh variable whose scope is the BODY.  It is set to START,							;; VAR is a fresh variable whose scope is the BODY.  It is set to START,
;; and then the BODY is executed.  If VAR is ever END after executing the							;; and then the BODY is executed.  If VAR is ever END after executing the
;; body, then the construct immediately terminates.  Otherwise, VAR is								;; body, then the construct immediately terminates.  Otherwise, VAR is
;; incremented by 1 and the BODY is executed again.  START may be equal to							;; incremented by 1 and the BODY is executed again.  START may be equal to
;; END, in which case the BODY is executed exactly once.  If the values of							;; END, in which case the BODY is executed exactly once.  If the values of
;; START and END ever change during evaluation, or if BODY ever sets VAR to							;; START and END ever change during evaluation, or if BODY ever sets VAR to
;; START-1, the behavior of the entire program becomes undefined.								;; START-1, the behavior of the entire program becomes undefined.

(defconstruct for (var = start wordto end &body body)										(defconstruct for (var = start wordto end &body body)
  (let ((top (gentemp "_FORTOP"))	;Loop entry point.									  (let ((top (gentemp "_FORTOP"))	;Loop entry point.
	(bot (gentemp "_FORBOT"))	;Bottom of loop.										(bot (gentemp "_FORBOT"))	;Bottom of loop.
	(stvar (gentemp "_FORSTART"))													(stvar (gentemp "_FORSTART"))
	(endvar (gentemp "_FOREND")))	;Loop boundary values.										(endvar (gentemp "_FOREND")))	;Loop boundary values.
    `(let (,stvar <- ,start)													    `(let (,stvar <- ,start)
	  (let (,endvar <- (,end + 1))													  (let (,endvar <- (,end + 1))
	       (scope ,var														       (scope ,var
		      (,var <- ,stvar)														      (,var <- ,stvar)
		      ;; The loop itself.													      ;; The loop itself.
		      (bcs-branch-pair ,top (,var != ,stvar)											      (bcs-branch-pair ,top (,var != ,stvar)
				       ,bot (,var != ,endvar)													       ,bot (,var != ,endvar)
			,@body																,@body
		        (,var ++))														        (,var ++))
		      (,var -> ,endvar))))))													      (,var -> ,endvar))))))

;; GOTO - Compute an address and go to it.  The destination must								;; GOTO - Compute an address and go to it.  The destination must
;; contain appropriate instructions to accept this transfer of control.								;; contain appropriate instructions to accept this transfer of control.
;; If the optional LABEL is provided, it provides a name for the								;; If the optional LABEL is provided, it provides a name for the
;; origin for the destination instruction to refer to.										;; origin for the destination instruction to refer to.

(defconstruct goto (expr &optional from label)											(defconstruct goto (expr &optional from label)
  (cond																  (cond
   ((register? expr)														   ((register? expr)
    (if label															    (if label
	`((label ,label)														`((label ,label)
	  (swapbr ,expr))														  (swapbr ,expr))
      `(swapbr ,expr)))														      `(swapbr ,expr)))
   (t																   (t
    (extract form env))))													    (extract form env))))

(defconstruct comefrom (expr &optional to label)										(defconstruct comefrom (expr &optional to label)
  (cond																  (cond
   ((register? expr)														   ((register? expr)
    (if label															    (if label
	`((label ,label)														`((label ,label)
	  (swapbr ,expr))														  (swapbr ,expr))
      `(swapbr ,expr)))														      `(swapbr ,expr)))
   (t																   (t
    (extract form env))))													    (extract form env))))

(defconstruct go (to label1 from label2)											(defconstruct go (to label1 from label2)
  `(sbra label2 label1))												      |	  `(sbra ,label2 ,label1))

(defconstruct come (from label1 to label2)											(defconstruct come (from label1 to label2)
  `(sbra label2 label1))												      |	  `(sbra ,label2 ,label1))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Medium-level control flow constructs not intended										;;; Medium-level control flow constructs not intended
;;; for direct user use.													;;; for direct user use.

;; InfLoop: Unconditional branch from bottom of body back to top.								;; InfLoop: Unconditional branch from bottom of body back to top.
;; Also, if we hit it from outside we jump over it.										;; Also, if we hit it from outside we jump over it.
(defconstruct infloop (&body body)												(defconstruct infloop (&body body)
  `(twin-us-branch ,(gentemp "_LOOPTOP") ,(gentemp "_LOOPBOT")									  `(twin-us-branch ,(gentemp "_LOOPTOP") ,(gentemp "_LOOPBOT")
		   . ,body))															   . ,body))

;; ifelse: Lower-level form of (if CONDEXPR then BODY1 else BODY2) that								;; ifelse: Lower-level form of (if CONDEXPR then BODY1 else BODY2) that
;; lacks the nice infix notation.												;; lacks the nice infix notation.

(defconstruct ifelse (condexpr ifstuff elsestuff)										(defconstruct ifelse (condexpr ifstuff elsestuff)
  (cond																  (cond
   ((and (listp condexpr)													   ((and (listp condexpr)
	 (null (cdddr condexpr))													 (null (cdddr condexpr))
	 (member (second condexpr) '(= != > <= < >=)))											 (member (second condexpr) '(= != > <= < >=)))
    `(_ifelse ,condexpr ,ifstuff ,elsestuff)))											    `(_ifelse ,condexpr ,ifstuff ,elsestuff)))
  )																  )
      																      
;; Table of opposites of relational symbols.											;; Table of opposites of relational symbols.
(setf (get '=  'opposite) '!=													(setf (get '=  'opposite) '!=
      (get '!= 'opposite) '=													      (get '!= 'opposite) '=
      (get '>  'opposite) '<=													      (get '>  'opposite) '<=
      (get '<= 'opposite) '>													      (get '<= 'opposite) '>
      (get '<  'opposite) '>=													      (get '<  'opposite) '>=
      (get '>= 'opposite) '<													      (get '>= 'opposite) '<
      )																      )

;;; _if (VAR ~ VAL) then BODY													;;; _if (VAR ~ VAL) then BODY
(defconstruct _if ((exp1 ~ exp2) then &body body)										(defconstruct _if ((exp1 ~ exp2) then &body body)
  (let ((l1 (gentemp "_IFTOP"))													  (let ((l1 (gentemp "_IFTOP"))
	(l2 (gentemp "_IFBOT")))												        (l2 (gentemp "_IFBOT")))
    `(twin-bcs-branch (,exp1 ,(opposite ~) ,exp2) ,l1 ,l2									    `(twin-bcs-branch (,exp1 ,(opposite ~) ,exp2) ,l1 ,l2
	;; The body sure better not change whether the relation holds.									;; The body sure better not change whether the relation holds.
	,@body)))															,@body)))

(defconstruct _ifelse ((exp1 ~ exp2) ifstuff elsestuff)										(defconstruct _ifelse ((exp1 ~ exp2) ifstuff elsestuff)
  (let ((iftop (gentemp "_IFTOP"))												  (let ((iftop (gentemp "_IFTOP"))
	(ifbot (gentemp "_IFBOT"))												        (ifbot (gentemp "_IFBOT"))
	(elsetop (gentemp "_ELSETOP"))												        (elsetop (gentemp "_ELSETOP"))
	(elsetop (gentemp "_ELSEBOT")))											      |	        (elsebot (gentemp "_ELSEBOT")))
															      >	    #|
    `((bcs-branch (,exp1 ,(opposite ~) ,exp2) ,iftop ,elsetop)									    `((bcs-branch (,exp1 ,(opposite ~) ,exp2) ,iftop ,elsetop)
      (ensure-green . ,ifstuff)													      (ensure-green . ,ifstuff)
      (sbra ,ifbot ,elsebot)													      (sbra ,ifbot ,elsebot)
      (sbra ,elsetop ,iftop)													      (sbra ,elsetop ,iftop)
      (ensure-green . ,elsestuff)												      (ensure-green . ,elsestuff)
      (bcs-branch (,exp1 ,~ ,exp2) ,elsebot ,ifbot))										      (bcs-branch (,exp1 ,~ ,exp2) ,elsebot ,ifbot))
    ))															      |	    |#
															      >	    `((twin-bcs-branch (,exp1 ,(opposite ~) ,exp2) ,iftop ,ifbot
															      >	       ,.ifstuff)
															      >	      (twin-bcs-branch (,exp1 ,~ ,exp2) ,elsetop ,elsebot
															      >	       ,.elsestuff))
															      >	  )
															      >	)
      																      
diff -ryw '--width=260' '--exclude=README.*' ../src/environment.lisp ../src2/environment.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;; ======================================================================							;;; ======================================================================
;;; This file defines the interface to and implementation of ENVIRONMENT							;;; This file defines the interface to and implementation of ENVIRONMENT
;;; objects.  An environment object determines what variables are present							;;; objects.  An environment object determines what variables are present
;;; in the R environment at a given point in the program, and where they							;;; in the R environment at a given point in the program, and where they
;;; are stored.  The environment also maintains identifiers for static								;;; are stored.  The environment also maintains identifiers for static
;;; objects.  This file provides the programmer's interface to environment							;;; objects.  This file provides the programmer's interface to environment
;;; objects, and should be used in lieu of manipulating the underlying								;;; objects, and should be used in lieu of manipulating the underlying
;;; structures directly.  This is intended to reduce errors and allow								;;; structures directly.  This is intended to reduce errors and allow
;;; environments to be reimplemented at a later time.										;;; environments to be reimplemented at a later time.
;;; ======================================================================							;;; ======================================================================

(defun empty-locmap () '())													(defun empty-locmap () '())

(defclass environment ()													(defclass environment ()
  ((variable-locations														  ((variable-locations
    :type list ;More specifically an ALIST from identifiers to locations.							    :type list ;More specifically an ALIST from identifiers to locations.
    :initform (empty-locmap)													    :initform (empty-locmap)
    :initarg :locmap														    :initarg :locmap
    :accessor locmap														    :accessor locmap
    :documentation "An ALIST of the form ((<var1> . <location1>) ...).								    :documentation "An ALIST of the form ((<var1> . <location1>) ...).
       Each VAR is a symbol, and only appears once in the alist.  The								       Each VAR is a symbol, and only appears once in the alist.  The
       variables that have most recently been created or moved appear at							       variables that have most recently been created or moved appear at
       the front of the alist.")												       the front of the alist.")
   (static-value-identifiers													   (static-value-identifiers
    :type list															    :type list
    :initform nil														    :initform nil
    :initarg :staticvals													    :initarg :staticvals
    :accessor staticvals													    :accessor staticvals
    :documentation "A list of identifier symbols that denote static								    :documentation "A list of identifier symbols that denote static
       data values permanently located in memory.")										       data values permanently located in memory.")
   (static-array-identifiers													   (static-array-identifiers
    :type list															    :type list
    :initform nil														    :initform nil
    :initarg :staticarrays													    :initarg :staticarrays
    :accessor staticarrays													    :accessor staticarrays
    :documentation "A list of identifier symbols denoting static arrays.")							    :documentation "A list of identifier symbols denoting static arrays.")
															      >	   (string-identifiers
															      >	    :type list
															      >	    :initform nil
															      >	    :initarg :strings
															      >	    :accessor strings
															      >	    :documentation "An alist of identifier symbols denoting strings (char arrays).
															      >	       and their lengths in the form ((<var1> . <length>) ...).")
   )																   )
  (:documentation "An environment specifies the meanings of identifiers at							  (:documentation "An environment specifies the meanings of identifiers at
     a given point during the compilation of a program."))									     a given point during the compilation of a program."))

(defmacro make-environment (&rest args)												(defmacro make-environment (&rest args)
  `(make-instance 'environment . ,args))											  `(make-instance 'environment . ,args))

(defun empty-env ()														(defun empty-env ()
  (make-environment))														  (make-environment))

(defun copy-environment (env)													(defun copy-environment (env)
  (make-environment :locmap (copy-alist (locmap env))										  (make-environment :locmap (copy-alist (locmap env))
		    :staticvals (copy-list (staticvals env))									                    :staticvals (copy-list (staticvals env))
		    :staticarrays (copy-list (staticarrays env))))							      |	                    :staticarrays (copy-list (staticarrays env))
															      >	                    :strings (copy-alist (strings env)) ))

(defmethod env-to-list ((env environment))											(defmethod env-to-list ((env environment))
  `(:locmap ,(locmap env)													  `(:locmap ,(locmap env)
    :staticvals ,(staticvals env)												    :staticvals ,(staticvals env)
    :staticarrays ,(staticarrays env)))											      |	    :staticarrays ,(staticarrays env)
															      >	    :strings ,(strings env) ))

(defmethod print-object ((env environment) stream)										(defmethod print-object ((env environment) stream)
  (write (env-to-list env) :stream stream))											  (write (env-to-list env) :stream stream))

;; Return an environment like ENV, but with VAR bound to location LOC								;; Return an environment like ENV, but with VAR bound to location LOC
;; in the location map.														;; in the location map.
(defmethod set-loc (var loc (env environment))											(defmethod set-loc (var loc (env environment))
  (setf env (copy-environment env)												  (setf env (copy-environment env)
	(locmap env) `((,var .,loc).,(remove (assoc var (locmap env))									(locmap env) `((,var .,loc).,(remove (assoc var (locmap env))
					     (locmap env))))														     (locmap env))))
  env)																  env)

;; Return an environment that is just like the given environment ENV but							;; Return an environment that is just like the given environment ENV but
;; with the variable VAR removed from the location map.										;; with the variable VAR removed from the location map.
(defmethod remove-var (var (env environment))											(defmethod remove-var (var (env environment))
  (setf env (copy-environment env) 												  (setf env (copy-environment env) 
	(locmap env) (remove (assoc var (locmap env)) (locmap env)))									(locmap env) (remove (assoc var (locmap env)) (locmap env)))
  env)																  env)

;; Return non-nil iff the variable VAR exists in the environment ENV.								;; Return non-nil iff the variable VAR exists in the environment ENV.
(defmethod defined-in-env? (var (env environment))										(defmethod defined-in-env? (var (env environment))
  (assoc var (locmap env)))													  (assoc var (locmap env)))

;; Return the location of variable VAR in environment ENV, or nil if VAR							;; Return the location of variable VAR in environment ENV, or nil if VAR
;; does not exist in the environment.  This is not guaranteed to be								;; does not exist in the environment.  This is not guaranteed to be
;; distinct from the null location.  (The DEFINED-IN-ENV function can be							;; distinct from the null location.  (The DEFINED-IN-ENV function can be
;; used to distinguish the two cases.)												;; used to distinguish the two cases.)
(defmethod location (var (env environment))											(defmethod location (var (env environment))
  (cdr (assoc var (locmap env))))												  (cdr (assoc var (locmap env))))

;; Return the variable stored at the given location in the given								;; Return the variable stored at the given location in the given
;; environment, or nil if none.													;; environment, or nil if none.
(defmethod var-at-loc (loc (env environment))											(defmethod var-at-loc (loc (env environment))
  (car (rassoc loc (locmap env) :test #'equal)))										  (car (rassoc loc (locmap env) :test #'equal)))

;; Return non-nil iff the two environments E1 and E2 contain the exact same							;; Return non-nil iff the two environments E1 and E2 contain the exact same
;; set of variables.														;; set of variables.
(defmethod equal-vars? ((e1 environment) (e2 environment))									(defmethod equal-vars? ((e1 environment) (e2 environment))
  (let ((answer t))														  (let ((answer t))
    (dolist (v (append (mapcar #'car (locmap e1)) (mapcar #'car (locmap e2))))							    (dolist (v (append (mapcar #'car (locmap e1)) (mapcar #'car (locmap e2))))
	(if (not (and (assoc v (locmap e1)) (assoc v (locmap e2))))									(if (not (and (assoc v (locmap e1)) (assoc v (locmap e2))))
	    (setf answer nil)))														    (setf answer nil)))
    answer))															    answer))

;; Return non-nil iff the two environments E1 and E2 are equivalent, in the							;; Return non-nil iff the two environments E1 and E2 are equivalent, in the
;; sense that they have the same variables and assign them to the same								;; sense that they have the same variables and assign them to the same
;; locations.															;; locations.
(defmethod equal-env? ((e1 environment) (e2 environment))									(defmethod equal-env? ((e1 environment) (e2 environment))
  (let ((answer t))														  (let ((answer t))
    (dolist (v (append (mapcar #'car (locmap e1)) (mapcar #'car (locmap e2))))							    (dolist (v (append (mapcar #'car (locmap e1)) (mapcar #'car (locmap e2))))
      (if (not (equal (assoc v (locmap e1)) (assoc v (locmap e2))))								      (if (not (equal (assoc v (locmap e1)) (assoc v (locmap e2))))
	  (setf answer nil)))														  (setf answer nil)))
    answer))															    answer))

;; Return the first variable in environment E1 that is not located in the							;; Return the first variable in environment E1 that is not located in the
;; same place in environment E2.												;; same place in environment E2.
(defmethod first-misloc ((e1 environment) (e2 environment))									(defmethod first-misloc ((e1 environment) (e2 environment))
  (dolist (v (mapcar #'car (locmap e1)))											  (dolist (v (mapcar #'car (locmap e1)))
    (if (not (equal (cdr (assoc v (locmap e1))) (cdr (assoc v (locmap e2)))))							    (if (not (equal (cdr (assoc v (locmap e1))) (cdr (assoc v (locmap e2)))))
	(return v))))															(return v))))

;; Return the lowest-numbered available register location in the given								;; Return the lowest-numbered available register location in the given
;; environment.  Available means not containing any variable.  Registers 0							;; environment.  Available means not containing any variable.  Registers 0
;; and 1 are never available because 0 is reserved to contain 0 and 1 is							;; and 1 are never available because 0 is reserved to contain 0 and 1 is
;; reserved to be the stack pointer.  Returns nil if no registers are								;; reserved to be the stack pointer.  Returns nil if no registers are
;; available.															;; available.
(defmethod next-avail-reg ((env environment))											(defmethod next-avail-reg ((env environment))
  (let ((i 2))															  (let ((i 2))
    (loop															    (loop
     (if (not (rassoc `(reg ,i) (locmap env) :test #'equal))									     (if (not (rassoc `(reg ,i) (locmap env) :test #'equal))
	 (return `(reg ,i)))														 (return `(reg ,i)))
     (incf i)															     (incf i)
     (if (= i 32) (return)))))													     (if (= i 32) (return)))))

;; Return the first stack location ABOVE THE CURRENT STACK									;; Return the first stack location ABOVE THE CURRENT STACK
;; POINTER that is available (doesn't contain a variable) in the given								;; POINTER that is available (doesn't contain a variable) in the given
;; environment.  The stack grows down, so ABOVE means MORE NEGATIVE THAN.							;; environment.  The stack grows down, so ABOVE means MORE NEGATIVE THAN.
(defmethod next-avail-stack ((env environment))											(defmethod next-avail-stack ((env environment))
  (let ((i -1))															  (let ((i -1))
    (loop															    (loop
     (if (not (rassoc `(stack ,i) (locmap env) :test #'equal))									     (if (not (rassoc `(stack ,i) (locmap env) :test #'equal))
	 (return `(stack ,i)))														 (return `(stack ,i)))
     (decf i))))														     (decf i))))

;; Return a variable in the given environment that was least recently								;; Return a variable in the given environment that was least recently
;; created or moved.														;; created or moved.
(defmethod least-recently-moved ((env environment))										(defmethod least-recently-moved ((env environment))
  ;; Currently this information is maintained by putting newly-created or							  ;; Currently this information is maintained by putting newly-created or
  ;; moved variables on the front of the alist, so we just return the last							  ;; moved variables on the front of the alist, so we just return the last
  ;; variable on the list.													  ;; variable on the list.
  (car (nth (1- (length (locmap env))) (locmap env))))										  (car (nth (1- (length (locmap env))) (locmap env))))

;; Return non-nil if VAR is located in a register in environment ENV.								;; Return non-nil if VAR is located in a register in environment ENV.
(defmethod in-register? (var (env environment))											(defmethod in-register? (var (env environment))
  (register? (location var env)))												  (register? (location var env)))

;; Return the index of the topmost stack location at SP or below that								;; Return the index of the topmost stack location at SP or below that
;; has a variable in it.  In other words, where is										;; has a variable in it.  In other words, where is
;; the top of the stack in relation to the current stack pointer.								;; the top of the stack in relation to the current stack pointer.
(defmethod top-of-stack ((env environment))											(defmethod top-of-stack ((env environment))
  (let ((h 0))															  (let ((h 0))
    (dolist (loc (locmap env))													    (dolist (loc (locmap env))
      (if (eq (cadr loc) 'stack)												      (if (eq (cadr loc) 'stack)
	  (if (< (caddr loc) h)														  (if (< (caddr loc) h)
	      (setf h (caddr loc)))))													      (setf h (caddr loc)))))
    h))																    h))

(defmethod add-staticval (name (env environment))										(defmethod add-staticval (name (env environment))
  (setf env (copy-environment env)												  (setf env (copy-environment env)
	(staticvals env) (cons name (staticvals env)))											(staticvals env) (cons name (staticvals env)))
  env)																  env)

(defmethod add-staticarray (name (env environment))										(defmethod add-staticarray (name (env environment))
  (setf env (copy-environment env)												  (setf env (copy-environment env)
	(staticarrays env) (cons name (staticarrays env)))										(staticarrays env) (cons name (staticarrays env)))
  env)																  env)
															      >
															      >	(defmethod add-string (name length (env environment))
															      >	  (setf env (copy-environment env)
															      >		(strings env) (cons `(,name ,length) (strings env)))
															      >
															      >	  (setf env (copy-environment env)
															      >		(staticarrays env) (cons name (staticarrays env)))
															      >	  
															      >	  env)
															      >
															      >	(defmethod string? (var (env environment))
															      >	  (assoc var (strings env)))
															      >
															      >	(defmethod get-string-length (var (env environment))
															      >	  (cadr (assoc var (strings env))))

(defmethod static-id? (obj (env environment))											(defmethod static-id? (obj (env environment))
  (and (symbolp obj)														  (and (symbolp obj)
       (or (member obj (staticvals env))											       (or (member obj (staticvals env))
	   (member obj (staticarrays env)))))												   (member obj (staticarrays env)))))

(defmethod dynamic-var? (obj (env environment))											(defmethod dynamic-var? (obj (env environment))
  (and (symbolp obj)														  (and (symbolp obj)
       (not (static-id? obj env))))												       (not (static-id? obj env))))

(defmethod static-array? (obj (env environment))										(defmethod static-array? (obj (env environment))
  (member obj (staticarrays env)))												  (member obj (staticarrays env)))

(defun negated-sym? (obj)													(defun negated-sym? (obj)
  (and (symbolp obj)														  (and (symbolp obj)
       (eq #\- (elt (symbol-name obj) 0))))											       (eq #\- (elt (symbol-name obj) 0))))

(defun positive-of (negsym)													(defun positive-of (negsym)
  (intern (subseq (symbol-name negsym) 1)))											  (intern (subseq (symbol-name negsym) 1)))

(defmethod literal? (obj (env environment))											(defmethod literal? (obj (env environment))
  (or (numberp obj)														  (or (numberp obj)
      ;; Static array identifiers are literals because they stand for their							      ;; Static array identifiers are literals because they stand for their
      ;; addresses, and are left in the form of symbols which are processed							      ;; addresses, and are left in the form of symbols which are processed
      ;; directly by the assembler. 												      ;; directly by the assembler. 
      (static-array? obj env)													      (static-array? obj env)
      ;; If FOO is a static array, -FOO is a literal also.									      ;; If FOO is a static array, -FOO is a literal also.
      (and (negated-sym? obj)													      (and (negated-sym? obj)
	   (static-array? (positive-of obj) env))											   (static-array? (positive-of obj) env))
      ;; Expression is the address of a static-val.										      ;; Expression is the address of a static-val.
      (static-val-addr? obj env)))												      (static-val-addr? obj env)))

(defmethod static-val? (obj (env environment))											(defmethod static-val? (obj (env environment))
  (member obj (staticvals env)))												  (member obj (staticvals env)))

(defmethod static-val-addr? (obj (env environment))										(defmethod static-val-addr? (obj (env environment))
  (and (listp obj)														  (and (listp obj)
       (eq (car obj) '&)													       (eq (car obj) '&)
       (null (cddr obj))													       (null (cddr obj))
       (static-val? (second obj) env)))												       (static-val? (second obj) env)))diff -ryw '--width=260' '--exclude=README.*' ../src/expression.lisp ../src2/expression.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;; This version of WITH allows any temporary effect, not just									;; This version of WITH allows any temporary effect, not just
;; variable binding, to be done and undone around the body.									;; variable binding, to be done and undone around the body.
(defconstruct with (statement &body body)											(defconstruct with (statement &body body)
  `(,statement															  `(,statement
    ,@body															    ,@body
    (undo ,statement)))														    (undo ,statement)))

;; Given any statements, do their reverse (undoing their effects).  Don't							;; Given any statements, do their reverse (undoing their effects).  Don't
;; depend too much on this always working yet.											;; depend too much on this always working yet.
(defconstruct undo (&rest statements)												(defconstruct undo (&rest statements)
  (unless (null statements)													  (unless (null statements)
    (dbind (first . rest) statements												    (dbind (first . rest) statements
      (if (list-of-statements? first)												      (if (list-of-statements? first)
	  `(undo ,@first . ,rest)													  `(undo ,@first . ,rest)
	(let ((statement (canonicalize-form first)))											(let ((statement (canonicalize-form first)))
	  `((undo . ,rest)														  `((undo . ,rest)
	    (,(opposite (first statement)) . ,(rest statement))))))))									    (,(opposite (first statement)) . ,(rest statement))))))))

;; Maps "expanding" binary operators to their do/undo statements. 								;; Maps "expanding" binary operators to their do/undo statements. 
(defparameter *expanding*													(defparameter *expanding*
  '((& ^=&) (<< ^=<<) (>> ^=>>) (* +=* -=*) (*/ +=*/ -=*/) (_ <-_ ->_)))							  '((& ^=&) (<< ^=<<) (>> ^=>>) (* +=* -=*) (*/ +=*/ -=*/) (_ <-_ ->_)))
(defun forw (binop)														(defun forw (binop)
  (cadr (assoc binop *expanding*)))												  (cadr (assoc binop *expanding*)))
(defun revers (binop)														(defun revers (binop)
  (or (caddr (assoc binop *expanding*))												  (or (caddr (assoc binop *expanding*))
      (cadr (assoc binop *expanding*))))											      (cadr (assoc binop *expanding*))))

(defun expression? (obj)													(defun expression? (obj)
  (and (listp obj)														  (and (listp obj)
       (not (location? obj))													       (not (location? obj))
       (not (statement? obj))))													       (not (statement? obj))))

;; This version of with doesn't evaluate expressions as many times.								;; This version of with doesn't evaluate expressions as many times.
;; but uses up linear space during body.  It only handles <- (bind) type							;; but uses up linear space during body.  It only handles <- (bind) type
;; statements though.														;; statements though.
(defconstruct _with ((var <- val) &body body)											(defconstruct _with ((var <- val) &body body)
  (cond																  (cond
   ((or (not (expression? val))													   ((or (not (expression? val))
	(literal? val env))														(literal? val env))
    `(with (,var <- ,val)													    `(with (,var <- ,val)
	   . ,body))															   . ,body))
   ((null (cddr val)) ; No more than 2 words in value expression.								   ((null (cddr val)) ; No more than 2 words in value expression.
    (cond															    (cond
     ((eq (first val) '*)													     ((eq (first val) '*)
      ;; These expansions are a bit questionable because what if the body							      ;; These expansions are a bit questionable because what if the body
      ;; tries to look at the dereferenced value also?  It will see 0 (or							      ;; tries to look at the dereferenced value also?  It will see 0 (or
      ;; whatever was in VAR) instead.  But the alternative, of introducing							      ;; whatever was in VAR) instead.  But the alternative, of introducing
      ;; yet another temporary and swapping the contents back before doing							      ;; yet another temporary and swapping the contents back before doing
      ;; the body, seems too inefficient.											      ;; the body, seems too inefficient.
      (if (or (register? (second val))												      (if (or (register? (second val))
	      (dynamic-var? (second val) env))												      (dynamic-var? (second val) env))
	  `((,var <->* ,(second val))													  `((,var <->* ,(second val))
	    ,@body															    ,@body
	    (,var <->* ,(second val)))													    (,var <->* ,(second val)))
	(let ((tv (gentemp)))														(let ((tv (gentemp)))
	  `(_with (,tv <- ,(second val))												  `(_with (,tv <- ,(second val))
	      `((,var <->* ,tv)														      `((,var <->* ,tv)
		,@body																,@body
		(,var <->* ,tv))))))))														(,var <->* ,tv))))))))
   (t																   (t
    (dbind (a1 ~ a2) val  ;But what about other expressions?									    (dbind (a1 ~ a2) val  ;But what about other expressions?
      (let ((rb (revers ~))													      (let ((rb (revers ~))
	    (fb (forw ~)))														    (fb (forw ~)))
	(cond																(cond
	 ((and (numberp a1) (numberp a2))												 ((and (numberp a1) (numberp a2))
	  `((,var <- ,(funcall ~ a1 a2)) ;Warning: this is too simplistic.								  `((,var <- ,(funcall ~ a1 a2)) ;Warning: this is too simplistic.
	    ,@body															    ,@body
	    (,var -> ,(funcall ~ a1 a2))))												    (,var -> ,(funcall ~ a1 a2))))
	 ((eq ~ '+)															 ((eq ~ '+)
	  `(with ((,var += ,a1)														  `(with ((,var += ,a1)
		  (,var += ,a2))														  (,var += ,a2))
	    ,@body))															    ,@body))
	 ((and (eq ~ '+) (not (expression? a1)))											 ((and (eq ~ '+) (not (expression? a1)))
	  `(_with (,var <- ,a2)														  `(_with (,var <- ,a2)
	      (with (,var += a1)													      (with (,var += a1)
		 ,@body)))															 ,@body)))
	 ((and (eq ~ '+) (not (expression? a2)))											 ((and (eq ~ '+) (not (expression? a2)))
	  `(_with (,var <- ,a1)														  `(_with (,var <- ,a1)
	      (with (,var += ,a2)													      (with (,var += ,a2)
		 ,@body)))															 ,@body)))
	 ((and (eq ~ '-) (not (expression? a2)))											 ((and (eq ~ '-) (not (expression? a2)))
	  `(_with (,var <- ,a1)														  `(_with (,var <- ,a1)
	      (with (,var -= ,a2)													      (with (,var -= ,a2)
		 ,@body)))															 ,@body)))
	 ((and (expression? a1) (expression? a2))											 ((and (expression? a1) (expression? a2))
	  (let ((tv1 (gentemp))														  (let ((tv1 (gentemp))
		(tv2 (gentemp)))														(tv2 (gentemp)))
	    `(let (,tv1 <- ,a1)														    `(let (,tv1 <- ,a1)
	       (let (,tv2 <- ,a2)													       (let (,tv2 <- ,a2)
		 (,var ,fb ,tv1 ,tv2)														 (,var ,fb ,tv1 ,tv2)
		 ,@body																 ,@body
		 (,var ,rb ,tv1 ,tv2)))))													 (,var ,rb ,tv1 ,tv2)))))
	 ((expression? a1)														 ((expression? a1)
	  (let ((tv (gentemp)))														  (let ((tv (gentemp)))
	    `(let (,tv <- ,a1)														    `(let (,tv <- ,a1)
	       (,var ,fb ,tv ,a2)													       (,var ,fb ,tv ,a2)
	       ,@body															       ,@body
	       (,var ,rb ,tv ,a2))))													       (,var ,rb ,tv ,a2))))
	 ((expression? a2)														 ((expression? a2)
	  (let ((tv (gentemp)))														  (let ((tv (gentemp)))
	    `(let (,tv <- ,a2)														    `(let (,tv <- ,a2)
	       (,var ,fb ,a1 ,tv)													       (,var ,fb ,a1 ,tv)
	       ,@body															       ,@body
	       (,var ,rb ,a1 ,tv))))													       (,var ,rb ,a1 ,tv))))
	 (t																 (t
	  `((,var ,fb ,a1 ,a2)														  `((,var ,fb ,a1 ,a2)
	    ,@body															    ,@body
	    (,var ,rb ,a1 ,a2)))))))))													    (,var ,rb ,a1 ,a2)))))))))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Variable binding and unbinding.  For most purposes this takes the								;;; Variable binding and unbinding.  For most purposes this takes the
;;; place of assignment.													;;; place of assignment.

;; Semantics of BIND: assuming that VAR is already clear,									;; Semantics of BIND: assuming that VAR is already clear,
;; set it to VAL.  														;; set it to VAL.  
(definfix (var <- val) :opposite ->												(definfix (var <- val) :opposite ->
  ;; Implemented using +=, but ^= would also work.										  ;; Implemented using +=, but ^= would also work.
  (cond																  (cond
   ((or (symbolp val) (numberp val) (register? val) (literal? val env))								   ((or (symbolp val) (numberp val) (register? val) (literal? val env))
    `(,var += ,val))														    `(,var += ,val))
   ((expression? val)														   ((expression? val)
    ;; Binary expression.													    ;; Binary expression.
    (destructuring-bind (a1 ~ a2) val	;What about other syntaxes?								    (destructuring-bind (a1 ~ a2) val	;What about other syntaxes?
      (cond															      (cond
       ((and (numberp a1) (numberp a2))												       ((and (numberp a1) (numberp a2))
	`(,var += ,(funcall ~ a1 a2)))	; Really too simplistic.									`(,var += ,(funcall ~ a1 a2)))	; Really too simplistic.
       ((eq ~ '+)														       ((eq ~ '+)
	`((,var += ,a1)															`((,var += ,a1)
	  (,var += ,a2)))														  (,var += ,a2)))
       ((eq ~ '-)														       ((eq ~ '-)
	`((,var += ,a1)															`((,var += ,a1)
	  (,var -= ,a2)))														  (,var -= ,a2)))
       ((eq ~ '^)														       ((eq ~ '^)
	`((,var ^= ,a1)															`((,var ^= ,a1)
	  (,var ^= ,a2)))														  (,var ^= ,a2)))
       ((eq ~ '*)														       ((eq ~ '*)
	`(,var +=* ,a1 ,a2))														`(,var +=* ,a1 ,a2))
       ((assoc ~ *expanding*)													       ((assoc ~ *expanding*)
	`(,var ,(forw ~) ,a1 ,a2))													`(,var ,(forw ~) ,a1 ,a2))
       ((extract form env :lvalues 1))												       ((extract form env :lvalues 1))
       (t															       (t
	(error "Don't know how to compile ~s." form)))))))										(error "Don't know how to compile ~s." form)))))))

;; Assuming that VAR=VAL, restore it to zero.											;; Assuming that VAR=VAL, restore it to zero.
(definfix (var -> val) :opposite <-												(definfix (var -> val) :opposite <-
  (cond																  (cond
   ((or (symbolp val) (numberp val) (register? val) (literal? val env))								   ((or (symbolp val) (numberp val) (register? val) (literal? val env))
    `(,var -= ,val))														    `(,var -= ,val))
   ((expression? val)														   ((expression? val)
    ;; Binary expression.													    ;; Binary expression.
    (destructuring-bind (a1 ~ a2) val												    (destructuring-bind (a1 ~ a2) val
      (cond															      (cond
       ((and (numberp a1) (numberp a2))												       ((and (numberp a1) (numberp a2))
	`(,var -= ,(funcall ~ a1 a2)))	; Really too simplistic.									`(,var -= ,(funcall ~ a1 a2)))	; Really too simplistic.
       ((eq ~ '+)														       ((eq ~ '+)
	`((,var -= ,a1)															`((,var -= ,a1)
	  (,var -= ,a2)))														  (,var -= ,a2)))
       ((eq ~ '-)														       ((eq ~ '-)
	`((,var -= ,a1)															`((,var -= ,a1)
	  (,var += ,a2)))														  (,var += ,a2)))
       ((eq ~ '^)														       ((eq ~ '^)
	`((,var ^= ,a1)															`((,var ^= ,a1)
	  (,var ^= ,a2)))														  (,var ^= ,a2)))
       ((eq ~ '*)														       ((eq ~ '*)
	`(,var -=* ,a1 ,a2))														`(,var -=* ,a1 ,a2))
       ((assoc ~ *expanding*)													       ((assoc ~ *expanding*)
	;; Use the appropriate reverse op if different from forward one.								;; Use the appropriate reverse op if different from forward one.
	`(,(revers ~) ,var ,a1 ,a2))													`(,(revers ~) ,var ,a1 ,a2))
       ((extract form env :lvalues 1))												       ((extract form env :lvalues 1))
       (t															       (t
	(error "Don't know how to compile ~s." form)))))))										(error "Don't know how to compile ~s." form)))))))
       																       

;;; ----------------------------------------------------------------------							;;; ----------------------------------------------------------------------
;;; New thingy.  constructs all use this same function EXTRACT to								;;; New thingy.  constructs all use this same function EXTRACT to
;;; automatically replace located variables with their locations, move								;;; automatically replace located variables with their locations, move
;;; stack variables into registers before operating on them, create								;;; stack variables into registers before operating on them, create
;;; temporary variables for subexpressions and compute their values.								;;; temporary variables for subexpressions and compute their values.

;; EXTRACT - you give it a form, and it returns code that									;; EXTRACT - you give it a form, and it returns code that
;; creates appropriate temporary stuff around it and gets variables								;; creates appropriate temporary stuff around it and gets variables
;; in registers together with a reduced version of the original									;; in registers together with a reduced version of the original
;; form.															;; form.
;;    RELEVANT-TERMS is a list of the indices (as per NTH or ELT) of those							;;    RELEVANT-TERMS is a list of the indices (as per NTH or ELT) of those
;; terms that are candidates for expanding.  If not provided, all terms are							;; terms that are candidates for expanding.  If not provided, all terms are
;; considered fair game.													;; considered fair game.
;;    LVALUES is similarly the index of or a list of the indices of								;;    LVALUES is similarly the index of or a list of the indices of
;; a term or terms that are considered to be "lvalues", that is,								;; a term or terms that are considered to be "lvalues", that is,
;; "destinations" where the value of the term is changed by the									;; "destinations" where the value of the term is changed by the
;; statement.  Anything in LVALUES is automatically also a candidate								;; statement.  Anything in LVALUES is automatically also a candidate
;; for expanding.														;; for expanding.
;;    The indices in both RELEVANT-TERMS and LVALUES refer to the								;;    The indices in both RELEVANT-TERMS and LVALUES refer to the
;; indices the terms have *after* any canonicalization.										;; indices the terms have *after* any canonicalization.
;;    NIL is returned if EXTRACT can't do anything.										;;    NIL is returned if EXTRACT can't do anything.

(defun extract (form env &key lvalues (relevant-terms										(defun extract (form env &key lvalues (relevant-terms
				       (labels ((countlist (n)													       (labels ((countlist (n)
						 (if (>= n 0)															 (if (>= n 0)
						     (cons n															     (cons n
						       (countlist														       (countlist
							(1- n))))))															(1- n))))))
					 (countlist (length form)))))													 (countlist (length form)))))
  (setf form (canonicalize-form form));So we can forget about infix.								  (setf form (canonicalize-form form));So we can forget about infix.
  (labels ((lvalue? (index)													  (labels ((lvalue? (index)
	     "Return non-NIL if the given index is the index of										     "Return non-NIL if the given index is the index of
              a term that is an LVALUE (modifiable term)."									              a term that is an LVALUE (modifiable term)."
	     (or (eql index lvalues)													     (or (eql index lvalues)
		 (and (listp lvalues)														 (and (listp lvalues)
		      (member index lvalues))))													      (member index lvalues))))
	   (candidate? (index)														   (candidate? (index)
	     "Return non-NIL if the given index is the index of a									     "Return non-NIL if the given index is the index of a
              term that is a candidate for expansion."										              term that is a candidate for expansion."
	     (or (member index relevant-terms)												     (or (member index relevant-terms)
		 (lvalue? index))))														 (lvalue? index))))
    ;; First we locate the first term that is an expression or									    ;; First we locate the first term that is an expression or
    ;; a literal, and convert it into a temporary variable.									    ;; a literal, and convert it into a temporary variable.
    (let (before)														    (let (before)
      (setf (cdr form)														      (setf (cdr form)
	    (repl2 (cdr form)														    (repl2 (cdr form)
		  #'(lambda (term index)													  #'(lambda (term index)
		      (if (and (candidate? index)												      (if (and (candidate? index)
			       (or (expression? term)													       (or (expression? term)
				   (literal? term env)))													   (literal? term env)))
			  (let ((tv (gentemp)))														  (let ((tv (gentemp)))
			    (if (lvalue? index)														    (if (lvalue? index)
				(setf before `(,tv <-> ,term))													(setf before `(,tv <-> ,term))
			      (setf before `(,tv <- ,term)))												      (setf before `(,tv <- ,term)))
			    tv)))															    tv)))
		  1))																  1))
      (when before														      (when before
	(return-from extract `(let ,before ,form))))											(return-from extract `(let ,before ,form))))
    ;; If any term is a static value identifier, wrap the statement in								    ;; If any term is a static value identifier, wrap the statement in
    ;; a binding of a temporary to the value's address and replace the								    ;; a binding of a temporary to the value's address and replace the
    ;; term with a dereferencing expression.											    ;; term with a dereferencing expression.
    (let (before)														    (let (before)
      (setf (cdr form)														      (setf (cdr form)
	    (repl2 (cdr form)														    (repl2 (cdr form)
		  #'(lambda (term index)													  #'(lambda (term index)
		      (if (and (candidate? index)												      (if (and (candidate? index)
			       (static-val? term env))													       (static-val? term env))
			  (let ((tv (gentemp)))														  (let ((tv (gentemp)))
			    (setf before `(,tv <- (& ,term)))												    (setf before `(,tv <- (& ,term)))
			    `(* ,tv))))															    `(* ,tv))))
		  1))																  1))
      (when before														      (when before
	(return-from extract `(let ,before ,form))))											(return-from extract `(let ,before ,form))))
    ;; Now look for variables and make sure they are in the environment.							    ;; Now look for variables and make sure they are in the environment.
    ;; If not, add them, but don't remove them afterwards.  This lets								    ;; If not, add them, but don't remove them afterwards.  This lets
    ;; user refrain from explicitly adding variables although he will								    ;; user refrain from explicitly adding variables although he will
    ;; still have to get rid of them manually.											    ;; still have to get rid of them manually.
    (let ((index 1))														    (let ((index 1))
      (dolist (term (cdr form))													      (dolist (term (cdr form))
	(when (and (dynamic-var? term env)												(when (and (dynamic-var? term env)
		   (candidate? index)														   (candidate? index)
		   (not (defined-in-env? term env)))												   (not (defined-in-env? term env)))
	  (return-from extract														  (return-from extract
	    `((add-to-env ,term)													    `((add-to-env ,term)
	      ,form)))															      ,form)))
	(incf index)))															(incf index)))
    ;; Next, get any mentioned variables into registers.									    ;; Next, get any mentioned variables into registers.
    (let ((index 1))														    (let ((index 1))
      (dolist (term (cdr form))													      (dolist (term (cdr form))
	(when (and (dynamic-var? term env)												(when (and (dynamic-var? term env)
		   (candidate? index)														   (candidate? index)
		   (not (in-register? term env)))												   (not (in-register? term env)))
	  (return-from extract														  (return-from extract
	    `((get-in-register ,term)													    `((get-in-register ,term)
	      ,form)))															      ,form)))
	(incf index)))															(incf index)))
    ;; Finally, replace variables with the registers they're in.								    ;; Finally, replace variables with the registers they're in.
    (let (found?)														    (let (found?)
      (setf (cdr form)														      (setf (cdr form)
	    (repl2 (cdr form)														    (repl2 (cdr form)
		  #'(lambda (term index)													  #'(lambda (term index)
		      (when (and (dynamic-var? term env)											      (when (and (dynamic-var? term env)
				 (candidate? index)														 (candidate? index)
				 (in-register? term env))													 (in-register? term env))
			(true! found?)															(true! found?)
			(location term env)))														(location term env)))
		  1))																  1))
      (if found? form))))		;End function EXTRACT.									      (if found? form))))		;End function EXTRACT.

diff -ryw '--width=260' '--exclude=README.*' ../src/files.lisp ../src2/files.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------						      |	;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;; File compilation code.												      |	;; Read R code from input file and writes PISA code to output file
															      |	;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
(defun rcompile-file (filename &key debug)											(defun rcompile-file (filename &key debug)
  (let (source)														      |	  (let (source ctime upal pal env ofile)
    (with-open-file (stream filename)											      |	    
															      >	    ;read R source code and print to screen
															      >	    (with-open-file (istream filename)
       (loop															      (loop
	(let ((next-form												      |	        (let ( (next-form (read istream nil :eof)) )
	       (read stream nil :eof)))											      <
	  (cond															          (cond
	   ((eq next-form :eof)													            ((eq next-form :eof)
	    (setf source (reverse source))											             (setf source (reverse source))
	    (return))														             (return))
															      >	           
	   (t															            (t
	    (push next-form source))))))											             (push next-form source)) ))))
    ;(format t "~&Source:~%")												      |	    
    ;(myprint source)													      |	    (format t "~%R Source Code:")
    (if debug														      |	    (myprint source t)
															      >	    
															      >
															      >	    ;compile R code and print output to screen
															      >	    (setq ctime (get-internal-run-time))
															      >	    
															      >	    (setq upal (if debug
	(rc source :debug t)													                   (rc source :debug t)
      (rc source))))													      |	                   (rc source)) )
															      >	    
															      >	    (setq ctime (- (get-internal-run-time) ctime))
															      >	    (setq ctime (/ ctime internal-time-units-per-second))
															      >	    (format t "~%Compile Time: ~s seconds~%" ctime)       
															      >	    
															      >	    (setq env (last upal))
															      >	    (setq upal (cdr (nbutlast upal 1)))
															      >
															      >	    (format t "~%PAL Code:~%")
															      >	    (myprint upal t)
															      >	    (format t "~%Final environment:~%")
															      >	    (print env)
															      >	    
															      >	    ;write unoptimized PAL code to .upal file in same directory as R input file
															      >	    (setq ofile (make-pathname :host (pathname-host filename)
															      >	                               :device (pathname-device filename)
															      >	                               :directory (pathname-directory filename)
															      >	                               :name (pathname-name filename)
															      >	                               :type "upal") )
															      >	      
															      >	    (with-open-file (ostream ofile :direction :output)
															      >	      (myprint upal ostream) )
															      >	      
															      >	      
															      >	    ;optimize PAL code and print output to screen
															      >	    (setq pal (peephole upal))
															      >	    
															      >	    (format t "~%Optimized PAL Code:~%")
															      >	    (myprint pal t)
															      >	    
															      >	    ;write optimized PAL code to .pal file in same directory as R input file
															      >	    (setq ofile (make-pathname :host (pathname-host filename)
															      >	                               :device (pathname-device filename)
															      >	                               :directory (pathname-directory filename)
															      >	                               :name (pathname-name filename)
															      >	                               :type "pal") )
															      >	      
															      >	    (with-open-file (ostream ofile :direction :output)
															      >	      (myprint pal ostream) )
															      >	    
															      >	  )
															      >	)
diff -ryw '--width=260' '--exclude=README.*' ../src/infrastructure.lisp ../src2/infrastructure.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Compilation infrastructure.													;;; Compilation infrastructure.

;; Given an object, return non-nil IFF it could possibly be an									;; Given an object, return non-nil IFF it could possibly be an
;; infix-operator statement.													;; infix-operator statement.
(defun infix-form? (form)													(defun infix-form? (form)
  (and (listp form)														  (and (listp form)
       (>= (length form) 2)													       (>= (length form) 2)
       (symbolp (second form))													       (symbolp (second form))
       (get (second form) 'is-infix)))												       (get (second form) 'is-infix)))

;; Given a form, get it into the canonical form where the operator is								;; Given a form, get it into the canonical form where the operator is
;; first.  NOTE: This function used to be named just "canonicalize",								;; first.  NOTE: This function used to be named just "canonicalize",
;; but that is a reserved name in the "EXT" package.  Changed 9/18/18.								;; but that is a reserved name in the "EXT" package.  Changed 9/18/18.
(defun canonicalize-form (form)													(defun canonicalize-form (form)
  (if (infix-form? form)													  (if (infix-form? form)
      `(,(second form) ,(first form) . ,(cddr form))										      `(,(second form) ,(first form) . ,(cddr form))
    form))															    form))

;; Given an object, if it's an operator (construct) symbol, return								;; Given an object, if it's an operator (construct) symbol, return
;; its definition.														;; its definition.
(defun definition (operator)													(defun definition (operator)
  (and (symbolp operator)													  (and (symbolp operator)
       (get operator 'construct-definition)))											       (get operator 'construct-definition)))

;; Given an operator (construct symbol), return the opposite operator.								;; Given an operator (construct symbol), return the opposite operator.
;; (Which will undo the effect of the given operator.)										;; (Which will undo the effect of the given operator.)
(defun opposite (operator)													(defun opposite (operator)
  (get operator 'opposite))													  (get operator 'opposite))

;; Given an object, return non-NIL iff it may potentially be a									;; Given an object, return non-NIL iff it may potentially be a
;; single form statement (not a label atom) with a definition.									;; single form statement (not a label atom) with a definition.
(defun statement? (form)													(defun statement? (form)
  (and (listp form)														  (and (listp form)
       (not (null form))													       (not (null form))
       (or (definition (car form))												       (or (definition (car form))
	   (infix-form? form))))													   (infix-form? form))))

;; Guess whether an object may be a list of statements/primitives.								;; Guess whether an object may be a list of statements/primitives.
(defun list-of-statements? (obj)												(defun list-of-statements? (obj)
  (and (listp obj)														  (and (listp obj)
       (not (statement? obj))													       (not (statement? obj))
       (not (null obj))														       (not (null obj))
       (statement? (car obj))))													       (statement? (car obj))))

;; DEFCONSTRUCT - Define how a particular construct is to be compiled.								;; DEFCONSTRUCT - Define how a particular construct is to be compiled.
;; Given a construct name symbol CNAME, lambda list LAMBDA-LIST, and body							;; Given a construct name symbol CNAME, lambda list LAMBDA-LIST, and body
;; statements BODY, define CNAME to be a reversible language construct with							;; statements BODY, define CNAME to be a reversible language construct with
;; structure given by LAMBDA-LIST and compilation generated by the BODY.							;; structure given by LAMBDA-LIST and compilation generated by the BODY.
;; During compilation the BODY gets executed with the variables mentioned							;; During compilation the BODY gets executed with the variables mentioned
;; in the LAMBDA-LIST bound to corresponding parts of the item to be								;; in the LAMBDA-LIST bound to corresponding parts of the item to be
;; compiled, and with the variable ENV bound to the variable-location								;; compiled, and with the variable ENV bound to the variable-location
;; environment in effect at the start of the statement.  The body should							;; environment in effect at the start of the statement.  The body should
;; return 2 values: the first is a list of statements to which this								;; return 2 values: the first is a list of statements to which this
;; statement is equivalent.  The second value indicates the environment in							;; statement is equivalent.  The second value indicates the environment in
;; effect after the given statement(s).  It may be NIL meaning that the								;; effect after the given statement(s).  It may be NIL meaning that the
;; source as a high-level statement does not affect the environment after							;; source as a high-level statement does not affect the environment after
;; the statement, although the compiled lower-level statements might.								;; the statement, although the compiled lower-level statements might.

(defmacro defconstruct (cname lambda-list &body body)										(defmacro defconstruct (cname lambda-list &body body)
  (let ((opposite														  (let ((opposite
	 (if (eq (car body) :opposite)													 (if (eq (car body) :opposite)
	     (prog1															     (prog1
	       (cadr body)														       (cadr body)
	       (setf body (cddr body)))													       (setf body (cddr body)))
	   cname)))															   cname)))
    `(setf (get ',cname 'opposite) ',opposite											    `(setf (get ',cname 'opposite) ',opposite
	   (get ',cname 'construct-definition)												   (get ',cname 'construct-definition)
	   #'(lambda (args env)														   #'(lambda (args env)
	       (let ((form (cons ',cname args)))											       (let ((form (cons ',cname args)))
		 (destructuring-bind ,lambda-list args												 (destructuring-bind ,lambda-list args
		   . ,body))))))														   . ,body))))))

(defmacro definfix ((leftarg opname &rest rightargs) &body body)								(defmacro definfix ((leftarg opname &rest rightargs) &body body)
  `(progn															  `(progn
     (defconstruct ,opname (,leftarg . ,rightargs)										     (defconstruct ,opname (,leftarg . ,rightargs)
       . ,body)															       . ,body)
     (true! (get ',opname 'is-infix))))												     (true! (get ',opname 'is-infix))))


;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::							;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;; RCOMP-ITERATIVE-BROKEN - An iterative (as opposed to recursive) version of							;; RCOMP-ITERATIVE-BROKEN - An iterative (as opposed to recursive) version of
;; RCOMP.  Implemented 8/4/01 because RCOMP and RCOMP-DEBUG seem to be								;; RCOMP.  Implemented 8/4/01 because RCOMP and RCOMP-DEBUG seem to be
;; seg-faulting on large programs, for reasons inexplicable other than								;; seg-faulting on large programs, for reasons inexplicable other than
;; by assuming that CLISP is running out of stack space or something.								;; by assuming that CLISP is running out of stack space or something.
;; (8/4) - Doesn't work, and not debugged yet.											;; (8/4) - Doesn't work, and not debugged yet.
;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::							;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
(defun rcomp-iterative-broken (source &key env debug)										(defun rcomp-iterative-broken (source &key env debug)
  ;; Default to starting with the empty environment.										  ;; Default to starting with the empty environment.
  (when (null env) (setf env (empty-env)))											  (when (null env) (setf env (empty-env)))
  (let ((orig-source source)													  (let ((orig-source source)
	(compiled '()))															(compiled '()))
    ;; Keep processing until no source code is left.										    ;; Keep processing until no source code is left.
    (loop															    (loop
      (if (null source) (return))												      (if (null source) (return))
      ;; Make sure that the source code (in case it's a single									      ;; Make sure that the source code (in case it's a single
      ;; statement) is in the canonical prefix (rather than infix)								      ;; statement) is in the canonical prefix (rather than infix)
      ;; form.															      ;; form.
      (setf source (canonicalize-form source))											      (setf source (canonicalize-form source))
      (cond															      (cond
       ;; If the source is a single statement, replace it with its								       ;; If the source is a single statement, replace it with its
       ;; expansion.														       ;; expansion.
       ((statement? source)													       ((statement? source)
	;; Source is a single non-label statement with a definition.									;; Source is a single non-label statement with a definition.
	(let ((def (definition (first source))))											(let ((def (definition (first source))))
	  (mvbind (compiled endenv)													  (mvbind (compiled endenv)
		  ;; Perform a single step of compilation.											  ;; Perform a single step of compilation.
		  (funcall def (cdr source) env)												  (funcall def (cdr source) env)
	     ;; Now, the source is the result of that step, and										     ;; Now, the source is the result of that step, and
	     ;; the environment is changed.  Keep going.										     ;; the environment is changed.  Keep going.
	     (setf source compiled)													     (setf source compiled)
	     (mvbind (recomp reenv)													     (mvbind (recomp reenv)
		     ;; Try compiling it further.												     ;; Try compiling it further.
		     (rcomp-iterative compiled :env env :debug debug)										     (rcomp-iterative compiled :env env :debug debug)
		;; The compiled code is the result of that while process.									;; The compiled code is the result of that while process.
		(setf compiled recomp)														(setf compiled recomp)
		;; It is important to return the environment resulting										;; It is important to return the environment resulting
		;; from the OUTER compilation step, in case the inner										;; from the OUTER compilation step, in case the inner
		;; one doesn't return anything useful.												;; one doesn't return anything useful.
		(setf env (or endenv reenv))													(setf env (or endenv reenv))
		;; Make sure to set the source to NIL so we stop here.										;; Make sure to set the source to NIL so we stop here.
		(setf source nil)														(setf source nil)
		))))																))))
       ((form-list? source)													       ((form-list? source)
	;; Source is a list of statements.  Let's go through them iteratively.								;; Source is a list of statements.  Let's go through them iteratively.
	(mvbind (firstcomp firstendenv)													(mvbind (firstcomp firstendenv)
		;; Compile the first statement all the way down to the assembly.								;; Compile the first statement all the way down to the assembly.
		(rcomp-iterative (first source) :env env :debug debug)										(rcomp-iterative (first source) :env env :debug debug)
	    ;; Add the compiled code obtained to COMPILED, and update									    ;; Add the compiled code obtained to COMPILED, and update
	    ;; the environment, and change SOURCE to its former CDR.									    ;; the environment, and change SOURCE to its former CDR.
	    (setf compiled (append compiled firstcomp))											    (setf compiled (append compiled firstcomp))
	    (setf env firstendenv)													    (setf env firstendenv)
	    (pop source)))														    (pop source)))
       (t															       (t
	;; In all other cases just compile the source to itself										;; In all other cases just compile the source to itself
	;; and leave the environment unchanged.  This is an uncompilable								;; and leave the environment unchanged.  This is an uncompilable
	;; or assembly language statement that should be included in the								;; or assembly language statement that should be included in the
	;; compiled output.														;; compiled output.
	(setf compiled source)														(setf compiled source)
	(setf source nil)														(setf source nil)
	))																))
      (when debug														      (when debug
	(format t "~&Original source:~%")												(format t "~&Original source:~%")
	(myprint orig-source)														(myprint orig-source)
	(format t "~&Compiled so far:~%")												(format t "~&Compiled so far:~%")
	(myprint compiled)														(myprint compiled)
	(format t "~&Source remaining:~%")												(format t "~&Source remaining:~%")
	(myprint source)														(myprint source)
	(format t "~&Environment: ~:w" env))												(format t "~&Environment: ~:w" env))
      )																      )
    (values compiled env)))													    (values compiled env)))

;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::							;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;; RCOMP - Given a statement or a list of statements to compile and an								;; RCOMP - Given a statement or a list of statements to compile and an
;; optional initial environment (which defaults to the empty									;; optional initial environment (which defaults to the empty
;; environment), return an equivalent list of compiled statements and								;; environment), return an equivalent list of compiled statements and
;; the environment in effect after them.											;; the environment in effect after them.
;;																;;
;; (8/4/01) - This version,													;; (8/4/01) - This version,
;; being recursive, seems to run out of memory easily.										;; being recursive, seems to run out of memory easily.

(defun rcomp (source &optional startenv)											(defun rcomp (source &optional startenv)
  (when (null startenv) (setf startenv (empty-env)))										  (when (null startenv) (setf startenv (empty-env)))
  (setf source (canonicalize-form source))											  (setf source (canonicalize-form source))
  (cond																  (cond
   ((null source)														   ((null source)
    (values source startenv))													    (values source startenv))
   ((statement? source)														   ((statement? source)
    ;; Source is a single non-label statement with a definition.								    ;; Source is a single non-label statement with a definition.
    (let ((def (definition (first source))))											    (let ((def (definition (first source))))
      (mvbind (compiled endenv)													      (mvbind (compiled endenv)
	      ;; Compile it once.													      ;; Compile it once.
	      (funcall def (cdr source) startenv)											      (funcall def (cdr source) startenv)
	 (mvbind (recomp reenv)														 (mvbind (recomp reenv)
		 ;; Try compiling it further.													 ;; Try compiling it further.
		 (rcomp compiled startenv)													 (rcomp compiled startenv)
	    (values recomp														    (values recomp
		    (or endenv reenv))))))													    (or endenv reenv))))))
   ((form-list? source)														   ((form-list? source)
    ;; Source is a list of statements.												    ;; Source is a list of statements.
    (mvbind (firstcomp firstendenv)												    (mvbind (firstcomp firstendenv)
	    ;; Compile first statement.													    ;; Compile first statement.
	    (rcomp (first source) startenv)												    (rcomp (first source) startenv)
       (mvbind (restcomp restendenv)												       (mvbind (restcomp restendenv)
	       ;; Compile remaining statements in environment from									       ;; Compile remaining statements in environment from
	       ;; first statement.													       ;; first statement.
	       (rcomp (rest source) firstendenv)											       (rcomp (rest source) firstendenv)
	  (values (if (listp firstcomp)													  (values (if (listp firstcomp)
		      (append firstcomp restcomp)												      (append firstcomp restcomp)
		    (cons firstcomp restcomp))													    (cons firstcomp restcomp))
		  restendenv))))														  restendenv))))
   (t																   (t
    ;; In all other cases just compile the source to itself									    ;; In all other cases just compile the source to itself
    ;; and leave the environment unchanged.											    ;; and leave the environment unchanged.
    (values (list source) startenv))))												    (values (list source) startenv))))

;(defparameter *annotate* '(defword defarray defsub defmain let if call rcall for exregstack swapregs movereg))			;(defparameter *annotate* '(defword defarray defsub defmain let if call rcall for exregstack swapregs movereg))
;(defparameter *annotate* '(defsub defmain if call rcall for exregstack swapregs movereg))					;(defparameter *annotate* '(defsub defmain if call rcall for exregstack swapregs movereg))
;(defparameter *annotate* '(defsub defmain if call rcall for relocate vacate))							;(defparameter *annotate* '(defsub defmain if call rcall for relocate vacate))
;(defparameter *annotate* '(defsub defmain if call rcall for))									;(defparameter *annotate* '(defsub defmain if call rcall for))
(defparameter *annotate* '())													(defparameter *annotate* '())

;; 																;; 
;; This version of RCOMP, for debugging purposes, prints out the entire								;; This version of RCOMP, for debugging purposes, prints out the entire
;; state of the partially-compiled program after each individual code								;; state of the partially-compiled program after each individual code
;; transformation.														;; transformation.
;; 																;; 
;; WHOLE represents the entire current state of the compilation,								;; WHOLE represents the entire current state of the compilation,
;; represented as a cons cell whose CDR is the current partially-compiled							;; represented as a cons cell whose CDR is the current partially-compiled
;; source, which MUST be a LIST of statements, not a single statement.								;; source, which MUST be a LIST of statements, not a single statement.
;; POINTER is a pointer to the cons cell whose CDR is the part of the								;; POINTER is a pointer to the cons cell whose CDR is the part of the
;; source that remains to be compiled.  In general, the CAR of this CDR								;; source that remains to be compiled.  In general, the CAR of this CDR
;; will be an ENV statement giving the current environment.									;; will be an ENV statement giving the current environment.
;; 																;; 
(defun rcomp-repl (whole &optional (pointer whole) (debug nil))									(defun rcomp-repl (whole &optional (pointer whole) (debug nil))
  (loop																  (loop
   (block myblock														    (block myblock
	  (when debug														      (when debug
	    (myprint (cdr whole)											      |		  (myprint (cdr whole))
		     (if (eq (caadr pointer) 'env)									      |	             #|  (if (eq (caadr pointer) 'env)
			 (cddr pointer)												                 (cddr pointer)
		       (cdr pointer)))	;Print thuh whole shebang.							      |	                 (cdr pointer))) |#	;Print thuh whole shebang.
	    (format t "~&---------------------------------------------------------------------- ")				        (format t "~&---------------------------------------------------------------------- ")
	    ;; (clear-input) (finish-output) ;These don't seem to work right.							        ;; (clear-input) (finish-output) ;These don't seem to work right.
	    ;; (read-line)													        ;; (read-line)
	    )															      )
	  (let ((source (cdr pointer))	;Remaining source to compile.								      (let ((source (cdr pointer))  ;Remaining source to compile.
		startenv)															startenv)
															      >	        
	    (if (and (listp source)	;List of statements.									        (if (and (listp source)           ;List of statements.
		     (listp (car source)) ;Non-label statement.									                 (listp (car source))     ;Non-label statement.
		     (eq (caar source) 'env)) ;Special (ENV <env>) statement.							                 (eq (caar source) 'env)) ;Special (ENV <env>) statement.
		(setf startenv (cadar source)) ;Get the <env>.								      |	          (setf startenv (cadar source))  ;Get the <env>
	      (progn 														          (progn 
		;; Invent an ENV statement and insert it.									            ;; Invent an ENV statement and insert it.
		(if debug (format t "~&Default environment.~%"))								            (if debug (format t "~&Default environment.~%"))
		(setf startenv (empty-env))											            (setf startenv (empty-env))
		(setf (cdr pointer)	;Alter our object as follows.								            (setf (cdr pointer)	;Alter our object as follows.
		      `((env ,startenv)											      |	                  `((env ,startenv) . ,source) )
			. ,source))											      |	            (if debug (myprint (cdr whole)) ) ;(cddr pointer)))
		(if debug (myprint (cdr whole) (cddr pointer)))								      |	          )
		))													      |	        )
															      >	        
	    ;; Now STARTENV is the current env, and current source obj is just							        ;; Now STARTENV is the current env, and current source obj is just
	    ;; after the initial env statement.												  ;; after the initial env statement.
	    (setf source (cddr pointer))											        (setf source (cddr pointer))
															      >	        
	    ;; If no statements left to compile, we're done.									        ;; If no statements left to compile, we're done.
	    (when (null source)													        (when (null source)
	      (return-from rcomp-repl whole))											          (return-from rcomp-repl whole))
															      >	        
	    (let ((form (car source)))												        (let ((form (car source)))
	      ;; From here on we approximately mirror structure of RCOMP.							          ;; From here on we approximately mirror structure of RCOMP.
															      >	          
	      ;; If first form is an infix form, canonicalize it.								          ;; If first form is an infix form, canonicalize it.
	      (when (infix-form? form)												          (when (infix-form? form)
					;(format t "~&Canonicalize.~%")							      |	            (if debug (format t "~%Canonicalizing: ~s~%" form))
		(setf form (canonicalize-form form)									      |	            (setf form (canonicalize-form form) (car source) form)
		      (car source) form)										      |	            (if debug (format t "canonicalized form: ~s~%" form))
					;(myprint (cdr whole))									            ;(myprint (cdr whole))
		)														          )
	      (cond													      |	          
	       ;; If first item is label: do nothing with it.								      |	          ;; If first item is label, do nothing with it.
	       ((atom form)												      |	          (when (atom form)
		(if debug (format t "~&Label.~%"))										            (if debug (format t "~&Label.~%"))
		(setf (cdr pointer) `(,form										      |	            (setf (cdr pointer)
															      >	                  `(,form
				      (env ,startenv)										                   (env ,startenv)
				      . ,(cdr source)))										                   . ,(cdr source)))
		(setf pointer (cdr pointer))											            (setf pointer (cdr pointer))
		(return-from myblock))												            (return-from myblock))
	       (t;; Else first item is a non-label STATEMENT.								      |	          
		(let ((first (first form)))										      |	          ;; Otherwise, first item is a non-label STATEMENT.
		  (if (symbolp first)											      |	          (let ((first (first form))
															      >	                def)
															      >	            
															      >	            (cond
															      >	             ((symbolp first)
		      ;; Assume source code is a single statement, FIRST is the symbol						              ;; Assume source code is a single statement, FIRST is the symbol
		      ;; naming the statement type, for dispatching.								              ;; naming the statement type, for dispatching.
		      (if (eq first 'env)										      |	               
			  (progn											      |	              (setq def (definition first))  ;get construct definition
															      >	                
															      >	              (when (eq first 'env)
			    (if debug (format t "~&Environment override.~%"))							                (if debug (format t "~&Environment override.~%"))
			    (setf (cdr pointer) source)										                (setf (cdr pointer) source)
			    (return-from myblock))										                (return-from myblock) )
			(let ((def (definition first)))									      |
			  (if (eq first 'defsub)									      |	              (when (eq first 'defsub)
			      (format t "~&Compiling ~s...~%" (second form)))							                (format t "~&Compiling ~s...~%" (second form)) )
															      >
			  (when (member first *annotate*)									              (when (member first *annotate*)
			    ;; Annote the compiler output with the source statement.						                ;; Annote the compiler output with the source statement.
			    (setf (cdr pointer)											                (setf (cdr pointer)
				  `((source ,form)										                      `((source ,form)
				    . ,(cdr pointer)))										                       . ,(cdr pointer)))
			    (setf pointer (cdr pointer))								      |	                (setf pointer (cdr pointer)) )
			    )												      |	              
			  (if (null def)										      |	              (when (null def)
			      ;; No definition for this.  Assume it's a final						      |	                ;; No definition for this statement.  Assume it's a final
			      ;; assembly instruction and doesn't change the						      |	                ;; assembly instruction and doesn't change the environment.
			      ;; environment.										      <
			      (progn											      <
				(if debug (format t "~&Final.~%"))								                (if debug (format t "~&Final.~%"))
				(setf (cdr pointer) `(,form								      |	                (setf (cdr pointer)
															      >	                  `(,form
						      (env ,startenv)								                   (env ,startenv)
						      . ,(cdr source)))								                   . ,(cdr source)))
				(setf pointer (cdr pointer))									                (setf pointer (cdr pointer))
				(return-from myblock))										                (return-from myblock) )
			    ;; OK, we do have a definition for it.							      |	              
															      >	              ;; There is a definition for the statement
			    (mvbind (compiled endenv)										              (mvbind (compiled endenv)
				    ;; Call the transformer function.								                ;; Call the transformer function.
				    (funcall def (cdr form) startenv)								                (funcall def (cdr form) startenv)
															      >	                      
				    ;; Insert result.										                ;; Insert result.
				    (if debug (format t "~&Expand ~s.~%" first))						                (if debug (format t "~&Expand ~s.~%" first))
				    (if (and endenv (null compiled))								                (if (and endenv (null compiled))
					(setf (cdr pointer)									                  (setf (cdr pointer)
					      `((env ,endenv)									                        `((env ,endenv)
						. ,(cdr source)))								                         . ,(cdr source)))
				      (setf (cddr pointer)									                  (setf (cddr pointer)
					    (if endenv										                        (if endenv
						`(,@(if compiled								                          `(,@(if compiled
							(if (not (form-list? compiled))						                                (if (not (form-list? compiled))
							    (list compiled)							                                  (list compiled)
							  compiled))								                                  compiled))
						    (env ,endenv)								                            (env ,endenv)
						    . ,(cdr source))								                            . ,(cdr source))
															      >	  
					      `(,@(if compiled									                          `(,@(if compiled
						      (if (not (form-list? compiled))						                                (if (not (form-list? compiled))
							  (list compiled)							                                  (list compiled)
							compiled))								                                  compiled))
						  . ,(cdr source)))))								                            . ,(cdr source)))) )
															      >	                      
				    ;; Try compiling same thing again.								                ;; Try compiling same thing again.
				    (return-from myblock)))))								      |	                (return-from myblock) ))
															      >	             
		    ;; The first item isn't a symbol so assume it's a statement							             ;; The first item isn't a symbol so assume it's a statement
		    ;; and treat the form as a list of statements.								             ;; and treat the form as a list of statements.
		    (progn												      |	             (t
		      (setf source (append form (cdr source))								      |	              (setf source
															      >	                    (append form (cdr source))
			    (cddr pointer) source)										                    (cddr pointer) source)
		      (if debug (format t "~&Insert statement list.~%"))							              (if debug (format t "~&Insert statement list.~%"))
		      (return-from myblock)))))))))))									      |	              (return-from myblock) )))))))
															      >	)
																  
;; RCOMP-ITERATIVE														;; RCOMP-ITERATIVE
(defun rcomp-iterative (source &key debug)											(defun rcomp-iterative (source &key debug)
  (let ((whole (cons nil (list source)))) ; see RCOMP-REPL for explanation of WHOLE						  (let ((whole (cons nil (list source)))) ; see RCOMP-REPL for explanation of WHOLE
    (rcomp-repl whole whole debug) ;; 2nd whole is pointer									    (rcomp-repl whole whole debug) ;; 2nd whole is pointer
    ))																    ))

;; The user-level compiler-debugging routine.											;; The user-level compiler-debugging routine.
(defun rcomp-debug (source)													(defun rcomp-debug (source)
  (rcomp-iterative source :debug t))												  (rcomp-iterative source :debug t))

(defun rcd (source)														(defun rcd (source)
  (rcomp-debug source))														  (rcomp-debug source))

;; non-nil iff obj could be a list of forms (not incl. label syms)								;; non-nil iff obj could be a list of forms (not incl. label syms)
(defun form-list? (obj)														(defun form-list? (obj)
  (and (listp obj)														  (and (listp obj)
       (not (and (car obj) (symbolp (car obj))))										       (not (and (car obj) (symbolp (car obj))))
       (not (and (cadr obj) (symbolp (cadr obj))))))										       (not (and (cadr obj) (symbolp (cadr obj))))))

;; Expand the source code to its compilation once, but not									;; Expand the source code to its compilation once, but not
;; recursively.  This is for debugging.												;; recursively.  This is for debugging.
(defun expand1 (source &optional env)												(defun expand1 (source &optional env)
  (let ((def (get (first source) 'construct-definition)))									  (let ((def (get (first source) 'construct-definition)))
    (if (null def)														    (if (null def)
	(values (list source) env)													(values (list source) env)
      (funcall def (cdr source) env))))												      (funcall def (cdr source) env))))

															      >
;; For testing.															;; For testing.
(defun myprint (code &optional pointer)											      |	;(defun myprint (code &optional pointer)
  (if (not (listp code))												      |	(defun myprint (code &optional (ostream t))
    (print code)													      |	  
  (progn														      |	  (cond ((not (listp code))
  #|(format t "~&~@													      |	         (pprint code)
             --------~@													      |	         (values) ))
             Program:~@													      |	  
             --------~%")|#												      |	  ;write header for simulator
  (format t "~&~%")													      |	  (if (not (eq ostream t))
  (if (list (car code))													      |	      (format ostream "~&;; pendulum pal file~%") )
															      >	  
															      >	  (format ostream "~%")
															      >
      (dolist (s code)														  (dolist (s code)
	(if (eq s (car pointer)) (format t "==>"))									      <
	(cond															    (cond
	 ((atom s) ;Interpret atoms as labels.										      |	       ;Interpret atoms as labels
	  (format t "~s:~15T" s))											      |	       ((atom s)  
															      >	        (format ostream "~s:~15T" s) )
															      >	     
															      >	       ;Print source code as comment if included
	 ((and (symbolp (car s))												       ((and (symbolp (car s))
	       (eq (car s) 'source))												             (eq (car s) 'source) )
	  (format t "~32T;;; ~w~%" (cadr s)))										      |	        (format ostream "~32T;;; ~w~%" (cadr s)) )
															      >
															      >	       ;Print regular instructions
	 ((and (symbolp (car s))												       ((and (symbolp (car s))
	       (not (get (car s) 'construct-definition))									             (not (get (car s) 'construct-definition))
	       (not (eq (car s) 'env))												             (not (eq (car s) 'env))
	       (not (and (symbolp (cadr s))											             (not (and (symbolp (cadr s))
			 (get (cadr s) 'construct-definition))))								                       (get (cadr s) 'construct-definition) )))
	  (format t "~16T")												      |	        (format ostream "~16T")
	  (dolist (w s)														        (dolist (w s)
	    (if (register? w)													          (if (register? w)
		(format t "$~s " (cadr w))										      |	              (format ostream "$~s " (cadr w))
	      (format t "~:w " w)))											      |	              (format ostream "~:w " w) ))
	  (format t "~%"))												      |	        (format ostream "~%") )
															      >
	 (t															       (t
	  (format t "~16T~<~:W~:>~%" s))))										      |	        (format ostream "~16T~<~:W~:>~%" s) )))
    (pprint code))													      |
  (format t "~&~%")													      |	  (format ostream "~&~%")
  (values)														      |	)
  )))															      |

(defun rc (source &key debug env) ;; ENV is currently ignored.									(defun rc (source &key debug env) ;; ENV is currently ignored.
  (mvbind (prog newenv)														  (mvbind (prog newenv)
	  (if debug														    (if debug
	      (rcd source)												      |	      (rcomp-iterative source :debug t)
	    (rcomp-iterative source :debug debug))									      |	      (rcomp-iterative source) )
	  (myprint prog)												      |
	  (format t "~&~%Final environment:")										      |	    (values prog)
	  (print newenv))												      |	  )
  (values))														      |	)

diff -ryw '--width=260' '--exclude=README.*' ../src/library.lisp ../src2/library.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

(defconstruct standard-library ()												(defconstruct standard-library ()
  ;; List of standardly available subroutines.											  ;; List of standardly available subroutines.
  '((def-smf)))															  '((def-smf)))

;; Define the simplest normal integer multiplication function.									;; Define the simplest normal integer multiplication function.
;; This adds the low word of the product of unsigned integers									;; This adds the low word of the product of unsigned integers
;; M1 and M2 into PROD.														;; M1 and M2 into PROD.

(defconstruct def-mult ()													(defconstruct def-mult ()
  '(defsub mult (m1 m2 prod)													  '(defsub mult (m1 m2 prod)
    ;; Use grade-school algorithm.												    ;; Use grade-school algorithm.
    (for pos = 0 to 31			; For each of the 32 bit-positions,							    (for pos = 0 to 31			; For each of the 32 bit-positions,
       (if (m1 & (1 << pos)) then	;   if that bit of m1 is 1, then							       (if (m1 & (1 << pos)) then	;   if that bit of m1 is 1, then
	 (prod += (m2 << pos))))))	;     add m2, shifted over to that								 (prod += (m2 << pos))))))	;     add m2, shifted over to that
					;       position, into p.													;       position, into p.

;; Define the signed multiplication-by-fraction function, which takes								;; Define the signed multiplication-by-fraction function, which takes
;; two signed integers M1 and M2, and adds the high word of their true								;; two signed integers M1 and M2, and adds the high word of their true
;; integer product into PROD.  This is like multiplying M1 by M2 when								;; integer product into PROD.  This is like multiplying M1 by M2 when
;; M2 is considered to represent a fraction with numerator explicit and								;; M2 is considered to represent a fraction with numerator explicit and
;; denominator 2^31.														;; denominator 2^31.
;;																;;
;; This version of the function was tested in C and seemed to work								;; This version of the function was tested in C and seemed to work
;; satisfactorily, although more testing is needed.  Need to compare								;; satisfactorily, although more testing is needed.  Need to compare
;; with upper bits of true (64-bit-wide) product. 6/26/97									;; with upper bits of true (64-bit-wide) product. 6/26/97

(defconstruct def-smf ()													(defconstruct def-smf ()
  '(defsub _smf (m1 m2 prod)													  '(defsub _smf (m1 m2 prod)
     (with-regvars (m1p m2p mask shifted bit p)											     (with-regvars (m1p m2p mask shifted bit p)
       (with ((mask <- 1)													       (with ((mask <- 1)
	      (m1p <- m1) (if (m1 < 0) then (- m1p))											      (m1p <- m1) (if (m1 < 0) then (- m1p))
	      (m2p <- m2) (if (m2 < 0) then (- m2p)))											      (m2p <- m2) (if (m2 < 0) then (- m2p)))
	  (mask <=< 31)															  (mask <=< 31)
	  (for position = 1 to 31													  (for position = 1 to 31
	     (mask >=> 1)														     (mask >=> 1)
	     (with (bit <- (m1p & mask))												     (with (bit <- (m1p & mask))
		(if bit then												      |			(if (bit) then
		  (with (shifted <- (m2p >> position))												  (with (shifted <- (m2p >> position))
		     (p += shifted)))))														     (p += shifted)))))
	  (if (m1 < 0) then (- p))													  (if (m1 < 0) then (- p))
	  (if (m2 < 0) then (- p))													  (if (m2 < 0) then (- p))
	  (prod += p)))))														  (prod += p)))))

diff -ryw '--width=260' '--exclude=README.*' ../src/loader.lisp ../src2/loader.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; This is the loader for the reversible compiler system.  Currently all							;;; This is the loader for the reversible compiler system.  Currently all
;;; files are just in the USER package.												;;; files are just in the USER package.

;; Load up the system.														;; Load up the system.
(load "util.lisp")            ; General-purpose utilities.									(load "util.lisp")            ; General-purpose utilities.
(load "infrastructure.lisp")  ; Mechanism for defining and compiling constructs.						(load "infrastructure.lisp")  ; Mechanism for defining and compiling constructs.
(load "location.lisp")        ; Describing locations where variables are stored.						(load "location.lisp")	      ; Describing locations where variables are stored.
(load "environment.lisp")     ; Mapping variables to their locations.								(load "environment.lisp")     ; Mapping variables to their locations.
(load "regstack.lisp")        ; Direct manipulation of registers and the stack.							(load "regstack.lisp")        ; Direct manipulation of registers and the stack.
(load "variables.lisp")       ; Creating, destroying, moving variables.								(load "variables.lisp")       ; Creating, destroying, moving variables.
(load "branches.lisp")        ; Branches, branch pairs, labels.									(load "branches.lisp")	      ; Branches, branch pairs, labels.
(load "expression.lisp")      ; Binding variables to multiply-nested expressions.						(load "expression.lisp")      ; Binding variables to multiply-nested expressions.
(load "clike.lisp")           ; C-like assignment-operator statements.								(load "clike.lisp")	      ; C-like assignment-operator statements.
(load "print.lisp")           ; Data output.											(load "print.lisp")	      ; Data output.
(load "controlflow.lisp")     ; High-level conditionals & loops.								(load "controlflow.lisp")     ; High-level conditionals & loops.
(load "subroutines.lisp")     ; Support for subroutine calls.									(load "subroutines.lisp")     ; Support for subroutine calls.
(load "staticdata.lisp")      ; Static data definitions.									(load "staticdata.lisp")      ; Static data definitions.
(load "program.lisp")         ; Highest-level constructs.  Standard library.							(load "program.lisp")	      ; Highest-level constructs.  Standard library.
(load "library.lisp")         ; Standard library of R routines.									(load "library.lisp")         ; Standard library of R routines.
(load "files.lisp")           ; File compiler.											(load "files.lisp")	      ; File compiler.

(load "../test/test.lisp")            ; Example programs.								      |	(load "strings.lisp")         ; String functions
															      >	(load "optimize.lisp")        ; Compiler optimization functions
															      >
															      >	(load "test.lisp")            ; Example programs.

;; Command to reload the system.												;; Command to reload the system.
(defun l () (load "loader.lisp"))           											(defun l () (load "loader.lisp"))			
Only in ../src2: loader-compiled.lisp
diff -ryw '--width=260' '--exclude=README.*' ../src/location.lisp ../src2/location.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;; ---------------------------------------------------------------------							;;; ---------------------------------------------------------------------
;;; A LOCATION object indicates where a variable is stored.									;;; A LOCATION object indicates where a variable is stored.
;;;																;;;
;;; The current implementation uses list structures.  If a <LOCATION> is							;;; The current implementation uses list structures.  If a <LOCATION> is
;;; NIL, then the variable exists in the environment but has no storage								;;; NIL, then the variable exists in the environment but has no storage
;;; location (and is therefore also unbound).  If a <LOCATION> is (REG								;;; location (and is therefore also unbound).  If a <LOCATION> is (REG
;;; <regno>) then the variable is located in register number <REGNO>.  If							;;; <regno>) then the variable is located in register number <REGNO>.  If
;;; <LOCATION> is (STACK <offset>) then the variable is located on the								;;; <LOCATION> is (STACK <offset>) then the variable is located on the
;;; stack at the address SP+<OFFSET>, where SP is the current value of the							;;; stack at the address SP+<OFFSET>, where SP is the current value of the
;;; stack pointer register.													;;; stack pointer register.
;;; ----------------------------------------------------------------------							;;; ----------------------------------------------------------------------

;; Return non-nil iff the object OBJ is a register location.									;; Return non-nil iff the object OBJ is a register location.
(defun register? (obj)														(defun register? (obj)
  (and (listp obj) (cdr obj) (null (cddr obj))											  (and (listp obj) (cdr obj) (null (cddr obj))
       (eq (car obj) 'reg)))													       (eq (car obj) 'reg)))

(defun stackloc? (obj)														(defun stackloc? (obj)
  (and (listp obj) (cdr obj) (null (cddr obj))											  (and (listp obj) (cdr obj) (null (cddr obj))
       (eq (car obj) 'stack)))													       (eq (car obj) 'stack)))

;; Return non-nil iff the object OBJ is a null location (meaning the								;; Return non-nil iff the object OBJ is a null location (meaning the
;; location of a variable that is not located anywhere).									;; location of a variable that is not located anywhere).
(defun null-loc? (obj)														(defun null-loc? (obj)
  (null obj))															  (null obj))

;; Return the given stack location's offset from the current stack								;; Return the given stack location's offset from the current stack
;; pointer.															;; pointer.
(defun offset (stackloc)													(defun offset (stackloc)
  (cadr stackloc))														  (cadr stackloc))

(defun location? (obj)														(defun location? (obj)
  (or (register? obj) (stackloc? obj)))												  (or (register? obj) (stackloc? obj)))
Only in ../src2: optimize.lisp
diff -ryw '--width=260' '--exclude=README.*' ../src/print.lisp ../src2/print.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

															      >	;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
															      >	;; I/O type specifiers
															      >	;; The high-order byte specifies the data type and
															      >	;; the low order byte specifies options.
															      >	;; Options are chosen by adding their values to
															      >	;; the value of the base type.
															      >	;; For example, to output and int as an unsigned hex number:
															      >	;;   (rawprint num (+ ptype-int int-unsigned int-base-16))
															      >	;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
															      >
															      >	;;---------------------------------
															      >	;; Integer type
															      >	;; Default: signed base 10
															      >	;;---------------------------------
															      >	(defconstant ptype-int    #x0000)
															      >
															      >	;sign representation
															      >	(defconstant int-signed     #x00)
															      >	(defconstant int-unsigned   #x01)
															      >
															      >	;base representation
															      >	(defconstant int-base-10    #x00)
															      >	(defconstant int-base-16    #x10)
															      >
															      >
															      >	;;-----------------------------------------
															      >	;; String type
															      >	;; Default: little endian
															      >	;;-----------------------------------------
															      >	(defconstant ptype-string         #x0100)
															      >
															      >	;byte-order representation
															      >	(defconstant string-little-endian   #x00)
															      >	(defconstant string-big-endian      #x01)
															      >
															      >
															      >	;;-----------------------------------------
															      >	;; Floating-point type
															      >	;; Default: fixed point notation
															      >	;;-----------------------------------------
															      >	(defconstant ptype-float   #x0200)
															      >
															      >	;notation representation
															      >	(defconstant float-fixed     #x00)
															      >	(defconstant float-exp       #x01)
															      >
															      >
															      >	;;----------------------------------
															      >	;; New line indicator
															      >	;;----------------------------------
															      >	(defconstant ptype-newline #xFF00)
															      >
															      >
															      >
															      >	(defconstruct print (val &key sign base)
															      >	  (cond
															      >	   ((or (static-val? val env)
															      >	        (numberp val) )
															      >	    (let ((type ptype-int))
															      >	      (if (eq sign 'unsigned)
															      >	        (setq type (+ type int-unsigned)) )
															      >	      (if (eq base 16)
															      >	        (setq type (+ type int-base-16)) )
															      >	    
															      >	    `((rawprint ,type)
															      >	      (rawprint ,val)) ))
															      >	   
															      >	   
															      >	   ((string? val env)
															      >	    (let (ptr)
															      >	      (dotimes (i (ceiling (get-string-length val env) 4))
															      >	        (setq ptr (append ptr (list i))) )
															      >	      
															      >	      `((rawprint ,ptype-string)
															      >	        ,(mapcar #'(lambda (p) `(rawprint (,val _ ,p))) ptr)) ))
															      >	   
															      >	   
															      >	   ((stringp val)
															      >	    `((rawprint ,ptype-string)
															      >	      ,(mapcar #'(lambda (word) `(rawprint ,word)) (pack-bytes (toascii val (length val))))) ) )
															      >	)
															      >
															      >
															      >	(defconstruct println (&optional (val nil))
															      >	  (if (null val)
															      >	    `((rawprint ,ptype-newline))
															      >	    `((print ,val) (rawprint ,ptype-newline)) )
															      >	)
															      >
															      >
(defconstruct printword (val)													(defconstruct printword (val)
  `((rawprint 0)													      |	  `((rawprint ,ptype-int)
    (rawprint ,val)))														    (rawprint ,val)))

(defconstruct println ()												      <
  `((rawprint 1)))													      <

(defconstruct rawprint (val)													(defconstruct rawprint (val)
  (cond																  (cond
   ((register? val)														   ((register? val)
    `(output ,val))														    `(output ,val))
   (t																   (t
    (extract form env))))													    (extract form env))))
															      >
															      >
															      >	;(defconstruct println ()
															      >	;  `((rawprint 1)) )
															      >

diff -ryw '--width=260' '--exclude=README.*' ../src/program.lisp ../src2/program.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;----------------------------------------------------------------------							;;----------------------------------------------------------------------
;;; Highest-level constructs.													;;; Highest-level constructs.

(defconstruct defmain (progname &body body)											(defconstruct defmain (progname &body body)
  `(;; Always include the standard library of subroutines.									  `(;; Always include the standard library of subroutines.
    (standard-library)													      |	    ;(standard-library)
    ;; We surround the whole program with a branch pair because I don't								    ;; We surround the whole program with a branch pair because I don't
    ;; think that our current idea of START/FINISH boundary instructions							    ;; think that our current idea of START/FINISH boundary instructions
    ;; can be non-noops on the real machine without dissipation. This								    ;; can be non-noops on the real machine without dissipation. This
    ;; also skips over main if control somehow comes down from above.								    ;; also skips over main if control somehow comes down from above.
    (twin-us-branch _MAINTOP _MAINBOT												    (twin-us-branch _MAINTOP _MAINBOT
      ;; Execution starts and ends with exactly 0 dynamic variables.								      ;; Execution starts and ends with exactly 0 dynamic variables.
      (with-location-map ,(empty-locmap)											      (with-location-map ,(empty-locmap)
        (declare-startpoint ,progname)												        (declare-startpoint ,progname)
        ;; To begin execution, the PC should initally be set to this label.							        ;; To begin execution, the PC should initally be set to this label.
        (label ,progname)													        (label ,progname)
	(start)																(start)
        ,@body															        ,@body
	(finish)))))															(finish)))))

;;----------------------------------------------------------------------							;;----------------------------------------------------------------------

;; Defprog: a whole program with subroutines and a main routine.								;; Defprog: a whole program with subroutines and a main routine.
;; Now deprecated in favor of defsub + defmain (6/26/97).									;; Now deprecated in favor of defsub + defmain (6/26/97).
(defconstruct defprog (progname subs &body main)										(defconstruct defprog (progname subs &body main)
  `(;; Always include the standard library of subroutines.									  `(;; Always include the standard library of subroutines.
    (standard-library)														    (standard-library)
    ;; Include user subroutines.												    ;; Include user subroutines.
    ,@subs															    ,@subs
    ;; We surround the whole program with a branch pair because I don't								    ;; We surround the whole program with a branch pair because I don't
    ;; think that our current idea of START/FINISH boundary instructions							    ;; think that our current idea of START/FINISH boundary instructions
    ;; can be implemented without dissipation.											    ;; can be implemented without dissipation.
    (twin-us-branch _MAINTOP _MAINBOT												    (twin-us-branch _MAINTOP _MAINBOT
     ;; Execution starts and ends with exactly nothing in the environment.							     ;; Execution starts and ends with exactly nothing in the environment.
     (with-location-map ,(empty-locmap)												     (with-location-map ,(empty-locmap)
       (declare-startpoint ,progname)												       (declare-startpoint ,progname)
       ;; To begin execution, the PC should initally be set to this label.							       ;; To begin execution, the PC should initally be set to this label.
       (label ,progname)													       (label ,progname)
       (start)															       (start)
       ,@main															       ,@main
       (finish)))))														       (finish)))))

;;----------------------------------------------------------------------							;;----------------------------------------------------------------------

(defconstruct declare-startpoint (labname)											(defconstruct declare-startpoint (labname)
  `(.start ,labname))														  `(.start ,labname))
diff -ryw '--width=260' '--exclude=README.*' ../src/regstack.lisp ../src2/regstack.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Register/stack manipulation.												;;; Register/stack manipulation.

(defconstruct relocate (var loc)												(defconstruct relocate (var loc)
  (let ((oldloc (location var env)))												  (let ((oldloc (location var env)))
    (if (not (equal oldloc loc))	;If not already there.									    (if (not (equal oldloc loc))	;If not already there.
	(if (null oldloc)														(if (null oldloc)
	    `((vacate ,loc)														    `((vacate ,loc)
	      (tell-loc ,var ,loc))													      (tell-loc ,var ,loc))
	  (if (null loc)														  (if (null loc)
	      `(tell-loc ,var ,loc)													      `(tell-loc ,var ,loc)
	    (let ((oldv (var-at-loc loc env)))												    (let ((oldv (var-at-loc loc env)))
	      (if oldv															      (if oldv
		  ;; If new location occupied, swap.												  ;; If new location occupied, swap.
		  `((swaploc ,oldloc ,loc)													  `((swaploc ,oldloc ,loc)
		    (tell-loc ,var ,loc)													    (tell-loc ,var ,loc)
		    (tell-loc ,oldv ,oldloc))													    (tell-loc ,oldv ,oldloc))
		;; Not occupied, just move.													;; Not occupied, just move.
		(if (null-loc? oldloc)														(if (null-loc? oldloc)
		    `(tell-loc ,var ,loc)													    `(tell-loc ,var ,loc)
		  `((moveloc ,oldloc ,loc)													  `((moveloc ,oldloc ,loc)
		    (tell-loc ,var ,loc))))))))))												    (tell-loc ,var ,loc))))))))))

;;; loc1 and loc2 should be register or stack locations.									;;; loc1 and loc2 should be register or stack locations.
(defconstruct swaploc (loc1 loc2)												(defconstruct swaploc (loc1 loc2)
  (if (and (register? loc1)													  (if (and (register? loc1)
	   (register? loc2))														   (register? loc2))
      `(swapregs ,loc1 ,loc2)													      `(swapregs ,loc1 ,loc2)
    (if (register? loc1)													    (if (register? loc1)
	`(exregstack ,loc1 ,loc2)													`(exregstack ,loc1 ,loc2)
      (if (register? loc2)													      (if (register? loc2)
	  `(exregstack ,loc2 ,loc1)													  `(exregstack ,loc2 ,loc1)
	;; We need a temporary register to facilitate the stack exchange;								;; We need a temporary register to facilitate the stack exchange;
	;; we choose reg. 31 for no particular reason.  The net change to								;; we choose reg. 31 for no particular reason.  The net change to
	;; it is nil.  This all works but could probably be made									;; it is nil.  This all works but could probably be made
	;; considerably more efficient.													;; considerably more efficient.
	`((exregstack (reg 31) ,loc1)													`((exregstack (reg 31) ,loc1)
	  (exregstack (reg 31) ,loc2)													  (exregstack (reg 31) ,loc2)
	  (exregstack (reg 31) ,loc1))))))												  (exregstack (reg 31) ,loc1))))))

;; Assuming loc2 is clear, move loc1 to it.											;; Assuming loc2 is clear, move loc1 to it.
(defconstruct moveloc (loc1 loc2)												(defconstruct moveloc (loc1 loc2)
  (if (and (register? loc1)													  (if (and (register? loc1)
	   (register? loc2))														   (register? loc2))
      `(movereg ,loc1 ,loc2)													      `(movereg ,loc1 ,loc2)
    (if (register? loc1)													    (if (register? loc1)
	`(exregstack ,loc1 ,loc2)													`(exregstack ,loc1 ,loc2)
      (if (register? loc2)													      (if (register? loc2)
	  `(exregstack ,loc2 ,loc1)													  `(exregstack ,loc2 ,loc1)
	;; We need a temporary register to facilitate the stack exchange;								;; We need a temporary register to facilitate the stack exchange;
	;; we choose reg. 31 for no particular reason.  The net change to								;; we choose reg. 31 for no particular reason.  The net change to
	;; it is nil.  This all works but could probably be made									;; it is nil.  This all works but could probably be made
	;; considerably more efficient.													;; considerably more efficient.
	`((exregstack (reg 31) ,loc1)													`((exregstack (reg 31) ,loc1)
	  (exregstack (reg 31) ,loc2)													  (exregstack (reg 31) ,loc2)
	  (exregstack (reg 31) ,loc1))))))												  (exregstack (reg 31) ,loc1))))))

;; Would save a lot of ADDI instructions if I changed this to modify the							;; Would save a lot of ADDI instructions if I changed this to modify the
;; stack pointer before but not after; and instead change the environment							;; stack pointer before but not after; and instead change the environment
;; to reflect correct new variable locations and amount of stack adjustment							;; to reflect correct new variable locations and amount of stack adjustment
;; from original.  But perhaps it would be better to leave the stack								;; from original.  But perhaps it would be better to leave the stack
;; pointer alone and get rid of adjacent ADDIs via a later peephole								;; pointer alone and get rid of adjacent ADDIs via a later peephole
;; optimization or something.													;; optimization or something.
(defconstruct exregstack (reg stackloc)												(defconstruct exregstack (reg stackloc)
  `(with-SP-adjustment ,(offset stackloc)											  `(with-SP-adjustment ,(offset stackloc)
	(exch ,reg (reg 1))))														(exch ,reg (reg 1))))

;; Given a register, push its contents onto the stack.  Not currently used.							;; Given a register, push its contents onto the stack.  Not currently used.
(defconstruct push (reg)													(defconstruct push (reg)
  `((exch ,reg (reg 1)) ;; <-- Convention: $1 is stack pointer.									  `((exch ,reg (reg 1)) ;; <-- Convention: $1 is stack pointer.
    (++ ,reg)))															    (++ ,reg)))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Pure register manipulation.													;;; Pure register manipulation.

;; swapregs R1 R2 - Given two registers, swap their contents.									;; swapregs R1 R2 - Given two registers, swap their contents.
(defconstruct swapregs (r1 r2)													(defconstruct swapregs (r1 r2)
  ;; Implementation for architectures that support XOR'ing regs, but not							  ;; Implementation for architectures that support XOR'ing regs, but not
  ;; swapping regs directly.  Another way uses +=, -=, and NEG but takes 4							  ;; swapping regs directly.  Another way uses +=, -=, and NEG but takes 4
  ;; instructions.														  ;; instructions.
  `((,r1 ^= ,r2)														  `((,r1 ^= ,r2)
    (,r2 ^= ,r1)														    (,r2 ^= ,r1)
    (,r1 ^= ,r2)))														    (,r1 ^= ,r2)))

;; Fast way to move r1 to r2 when r2 is known to be empty!  Otherwise								;; Fast way to move r1 to r2 when r2 is known to be empty!  Otherwise
;; behavior is "undefined" (actually in this implementation r1 gets r2, but							;; behavior is "undefined" (actually in this implementation r1 gets r2, but
;; r2 ends up with r2^r1).													;; r2 ends up with r2^r1).
(defconstruct movereg (r1 r2)													(defconstruct movereg (r1 r2)
  `((,r2 ^= ,r1)														  `((,r2 ^= ,r1)
    (,r1 ^= ,r2)))														    (,r1 ^= ,r2)))
Only in ../src2: sch.pal
Only in ../src2: sch.r
Only in ../src2: sch.upal
diff -ryw '--width=260' '--exclude=README.*' ../src/staticdata.lisp ../src2/staticdata.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Constructs for declaring static data.											;;; Constructs for declaring static data.

;; Define NAME to refer to a static word of data in memory									;; Define NAME to refer to a static word of data in memory
;; of value VALUE.														;; of value VALUE.
(defconstruct defword (name value)												(defconstruct defword (name value)
  `(skip															  `(skip
    (staticval ,name)														    (staticval ,name)
    (label ,name)														    (label ,name)
    (dataword ,value)))														    (dataword ,value)))

(defconstruct defarray (name &rest elements)											(defconstruct defarray (name &rest elements)
  `(skip															  `(skip
    (staticarray ,name)														    (staticarray ,name)
    (label ,name)														    (label ,name)
    . ,(mapcar #'(lambda (elem) `(dataword ,elem)) elements)))									    . ,(mapcar #'(lambda (elem) `(dataword ,elem)) elements)))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------

;; VALUE is a word of data that should be included at										;; VALUE is a word of data that should be included at
;; this point in the program in literal form.											;; this point in the program in literal form.
(defconstruct dataword (value)													(defconstruct dataword (value)
  `(data ,value))														  `(data ,value))

(defconstruct staticval (name)													(defconstruct staticval (name)
  (values nil (add-staticval name env)))											  (values nil (add-staticval name env)))

(defconstruct staticarray (name)												(defconstruct staticarray (name)
  (values nil (add-staticarray name env)))											  (values nil (add-staticarray name env)))

;; If the flow of control gets to code surrounded by SKIP it will skip over							;; If the flow of control gets to code surrounded by SKIP it will skip over
;; the contents without executing them.												;; the contents without executing them.
(defconstruct skip (&body body)													(defconstruct skip (&body body)
  ;; Implemented by an unconditional branch pair around the body.								  ;; Implemented by an unconditional branch pair around the body.
  `(sbra-pair ,(gentemp "_PRESKIP") ,(gentemp "_POSTSKIP")									  `(sbra-pair ,(gentemp "_PRESKIP") ,(gentemp "_POSTSKIP")
	     . ,body))															     . ,body))
Only in ../src2: strings.lisp
diff -ryw '--width=260' '--exclude=README.*' ../src/subroutines.lisp ../src2/subroutines.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Subroutine calling support.													;;; Subroutine calling support.
;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; User-level constructs.													;;; User-level constructs.

;; Defsub: Implements subroutine entry/return conventions.									;; Defsub: Implements subroutine entry/return conventions.
(defconstruct defsub (subname arglist &body body)										(defconstruct defsub (subname arglist &body body)
  (let ((bodyenv (entryenv arglist env)))											  (let ((bodyenv (entryenv arglist env)))
  ;; We wrap it in a branch pair so that if we encounter it from the								  ;; We wrap it in a branch pair so that if we encounter it from the
  ;; outside we jump over it, and if it runs off its end it comes back to							  ;; outside we jump over it, and if it runs off its end it comes back to
  ;; the beginning.  This latter behavior facilitates calling a subroutine							  ;; the beginning.  This latter behavior facilitates calling a subroutine
  ;; with a single switching-branch to its entry/exit point.									  ;; with a single switching-branch to its entry/exit point.
  `((twin-us-branch ,(gentemp "_SUBTOP") ,(gentemp "_SUBBOT") 									  `((twin-us-branch ,(gentemp "_SUBTOP") ,(gentemp "_SUBBOT") 		
      ;; At start and end of body, environment is as according									      ;; At start and end of body, environment is as according
      ;; to subroutine calling convention.											      ;; to subroutine calling convention.
      (declare-environment ,bodyenv)												      (declare-environment ,bodyenv)
      (portal ,subname) ;Entry/exit point.											      (portal ,subname) ;Entry/exit point.
      ,@body															      ,@body
      (environment ,bodyenv)))))												      (environment ,bodyenv)))))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Subroutine calling convention support.											;;; Subroutine calling convention support.

;; NOTE: Currently this does not work right for more than 29 arguments								;; NOTE: Currently this does not work right for more than 29 arguments
;; (i.e. when some args need to go on the top of the stack instead of								;; (i.e. when some args need to go on the top of the stack instead of
;; in registers!).														;; in registers!).
(defconstruct call (subname &rest actualargs)											(defconstruct call (subname &rest actualargs)
  `(withargs ,actualargs													  `(withargs ,actualargs
     (with-stack-top														     (with-stack-top
	(gosub ,subname))))														(gosub ,subname))))

(defconstruct rcall (subname &rest actualargs)											(defconstruct rcall (subname &rest actualargs)
  `(withargs ,actualargs													  `(withargs ,actualargs
     (with-stack-top														     (with-stack-top
	(rgosub ,subname))))														(rgosub ,subname))))

(defconstruct with-stack-top (&body body)											(defconstruct with-stack-top (&body body)
  (let ((offset (top-of-stack env)))												  (let ((offset (top-of-stack env)))
    `(with-sp-adjustment ,offset												    `(with-sp-adjustment ,offset
	. ,body)))															. ,body)))

(defconstruct with-SP-adjustment (amt &body body)										(defconstruct with-SP-adjustment (amt &body body)
  ;; AMT must be a literal number.												  ;; AMT must be a literal number.
  `(((reg 1) += ,amt)														  `(((reg 1) += ,amt)
    ,@body															    ,@body
    ((reg 1) -= ,amt)))														    ((reg 1) -= ,amt)))

;; Call a subroutine at a low level with no mention of arguments.								;; Call a subroutine at a low level with no mention of arguments.
(defconstruct gosub (subname) :opposite rgosub											(defconstruct gosub (subname) :opposite rgosub
  ;; A switching branch to the SWAPBRN in the portal should do the trick.							  ;; A switching branch to the SWAPBRN in the portal should do the trick.
  `(bra ,subname))														  `(bra ,subname))

(defconstruct rgosub (subname) :opposite gosub											(defconstruct rgosub (subname) :opposite gosub
  `(rbra ,subname))														  `(rbra ,subname))

;; Portal: Entry/exit point of a subroutine.											;; Portal: Entry/exit point of a subroutine.
(defconstruct portal (label)													(defconstruct portal (label)
  `((label ,label)														  `((label ,label)
    ;; We always use register $2 for storing our subroutine offsets, by								    ;; We always use register $2 for storing our subroutine offsets, by
    ;; convention.														    ;; convention.
    (swapbr (reg 2))  ;retvar<->BR												    (swapbr (reg 2))  ;retvar<->BR
    (neg (reg 2))     ;retvar = -retvar												    (neg (reg 2))     ;retvar = -retvar
    ))																    ))

;;; WITHARGS below needs some work.  It currently can only prepare the 29							;;; WITHARGS below needs some work.  It currently can only prepare the 29
;;; arguments that we can fit into registers.  I was intending that if								;;; arguments that we can fit into registers.  I was intending that if
;;; there are more arguments they should be passed on the stack.  This is							;;; there are more arguments they should be passed on the stack.  This is
;;; not too hard, but I'm not sure it's worth it.										;;; not too hard, but I'm not sure it's worth it.

;; Prepare arguments in conventional locations as for a subroutine call.							;; Prepare arguments in conventional locations as for a subroutine call.
(defconstruct withargs (actualargs &body body)											(defconstruct withargs (actualargs &body body)
  (let ((result `((vacate (reg 2))												  (let ((result `((vacate (reg 2))
		  . ,body))															  . ,body))
	(r 1))																(r 1))
    (dolist (a actualargs)													    (dolist (a actualargs)
      (if (and (symbolp a) (not (static-id? a env)))										      (if (and (symbolp a) (not (static-id? a env)))
	  (if (defined-in-env? a env)													  (if (defined-in-env? a env)
	      (push `(relocate ,a ,(argno-to-location r)) result)									      (push `(relocate ,a ,(argno-to-location r)) result)
	    (setf result														    (setf result
		  `((new-var-at ,a ,(argno-to-location r))											  `((new-var-at ,a ,(argno-to-location r))
		    ,@result															    ,@result
		    (remove-var ,a))))														    (remove-var ,a))))
	(setf result															(setf result
	      (let ((tv (gentemp)))													      (let ((tv (gentemp)))
		`((new-var-at ,tv ,(argno-to-location r))											`((new-var-at ,tv ,(argno-to-location r))
		  ;; This prevents evaluating A from causing											  ;; This prevents evaluating A from causing
		  ;; earlier-placed registers to change their locations.									  ;; earlier-placed registers to change their locations.
		  ;; 6/3/97- But ENSURE-GREEN really enforces more than										  ;; 6/3/97- But ENSURE-GREEN really enforces more than
		  ;; just this, unfortunately.													  ;; just this, unfortunately.
		  (ensure-green															  (ensure-green
		   (,tv <- ,a))															   (,tv <- ,a))
		  ,@result															  ,@result
		  (,tv -> ,a)															  (,tv -> ,a)
		  ;;^-DANGER! Assumes subroutine didn't change value of A.									  ;;^-DANGER! Assumes subroutine didn't change value of A.
		  (remove-var ,tv)))))														  (remove-var ,tv)))))
      (incf r))															      (incf r))
    result))															    result))
		       																       
;; On subroutine entry/exit, the environment contains:										;; On subroutine entry/exit, the environment contains:
;; A return-address variable located in register 2.										;; A return-address variable located in register 2.
;; All the arguments in registers 3,4,... until we run out,									;; All the arguments in registers 3,4,... until we run out,
;; and then stack locations -1,-2,... (below top of stack).									;; and then stack locations -1,-2,... (below top of stack).
;; If not all the registers were used for arguments, then									;; If not all the registers were used for arguments, then
;; there is a variable for each unused one (above 2), used									;; there is a variable for each unused one (above 2), used
;; to ensure that all these other registers are restored to									;; to ensure that all these other registers are restored to
;; their original state upon exit.												;; their original state upon exit.
(defun entryenv (arglist origenv)												(defun entryenv (arglist origenv)
  (let (locmap (r 0))														  (let (locmap (r 0))
    (dolist (a (cons '_RET arglist))												    (dolist (a (cons '_RET arglist))
      (push															      (push
       `(,a . ,(argno-to-location r))												       `(,a . ,(argno-to-location r))
       locmap)															       locmap)
      (incf r))															      (incf r))
    (setf r (+ r 2))														    (setf r (+ r 2))
    (if (<= r 31)														    (if (<= r 31)
	(loop																(loop
	 (push `(,(intern (concatenate 'string "_R" (princ-to-string r)))								 (push `(,(intern (concatenate 'string "_R" (princ-to-string r)))
		 reg ,r) locmap)														 reg ,r) locmap)
	 (incf r)															 (incf r)
	 (if (> r 31) (return))))													 (if (> r 31) (return))))
    (setf locmap (reverse locmap))												    (setf locmap (reverse locmap))
    (let ((env (copy-environment origenv)))											    (let ((env (copy-environment origenv)))
      (labels															      (labels
	  ((is-arg? (name) (member name arglist)))											  ((is-arg? (name) (member name arglist)))
	(setf (locmap env) locmap													(setf (locmap env) locmap
	      (staticvals env) (remove-if #'is-arg? (staticvals env))									      (staticvals env) (remove-if #'is-arg? (staticvals env))
	      (staticarrays env) (remove-if #'is-arg? (staticarrays env))))								      (staticarrays env) (remove-if #'is-arg? (staticarrays env))))
      env)))															      env)))

;; Convert an argument number (0 and up) to a location (reg <regno>)								;; Convert an argument number (0 and up) to a location (reg <regno>)
;; or (stack <offset>).  Argument 0 is the return address.									;; or (stack <offset>).  Argument 0 is the return address.
(defun argno-to-location (argno)												(defun argno-to-location (argno)
  (if (<= argno 29)														  (if (<= argno 29)
      `(reg ,(+ argno 2))													      `(reg ,(+ argno 2))
    `(stack ,(- 29 argno))))													    `(stack ,(- 29 argno))))

Only in ../src2: test.lisp
diff -ryw '--width=260' '--exclude=README.*' ../src/util.lisp ../src2/util.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; General utilities.														;;; General utilities.

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Some abbreviations for Common Lisp entities.										;;; Some abbreviations for Common Lisp entities.

;; Don't you agree that MULTIPLE-VALUE-BIND's name is too long?									;; Don't you agree that MULTIPLE-VALUE-BIND's name is too long?
(defmacro mvbind (&rest args)													(defmacro mvbind (&rest args)
  `(multiple-value-bind . ,args))												  `(multiple-value-bind . ,args))

;; Same here.															;; Same here.
(defmacro dbind (&rest args)													(defmacro dbind (&rest args)
  `(destructuring-bind . ,args))												  `(destructuring-bind . ,args))

;; IFMATCH - If the given FORM matches the given LAMBDA-LIST, then								;; IFMATCH - If the given FORM matches the given LAMBDA-LIST, then
;; execute BODY in a context where the variables in LAMBDA-LIST are								;; execute BODY in a context where the variables in LAMBDA-LIST are
;; lexically bound to the corresponding elements of FORM.  Otherise,								;; lexically bound to the corresponding elements of FORM.  Otherise,
;; just return NIL.  Differs from DBIND in that errors are ignored.								;; just return NIL.  Differs from DBIND in that errors are ignored.

(defmacro ifmatch (form lambda-list &body body)											(defmacro ifmatch (form lambda-list &body body)
  `(ignore-errors														  `(ignore-errors
    (dbind ,lambda-list ,form . ,body)))											    (dbind ,lambda-list ,form . ,body)))

;Another possible implementation:												;Another possible implementation:
;  (handler-case														;  (handler-case
;    (dbind ,lambda-list ,form . ,body)))											;    (dbind ,lambda-list ,form . ,body)))
;    (error (ignored))))													;    (error (ignored))))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Boolean shtuff.  Silly, but hey.												;;; Boolean shtuff.  Silly, but hey.

(defconstant true t)														(defconstant true t)
(defconstant false nil)														(defconstant false nil)

(defmacro true! (&rest places)													(defmacro true! (&rest places)
  `(setf . ,(mapcan #'(lambda (place) (list place true)) places)))								  `(setf . ,(mapcan #'(lambda (place) (list place true)) places)))
(defmacro false! (&rest places)													(defmacro false! (&rest places)
  `(setf . ,(mapcan #'(lambda (place) (list place false)) places)))								  `(setf . ,(mapcan #'(lambda (place) (list place false)) places)))

;; Convert an arbitrary object to a true-false value.										;; Convert an arbitrary object to a true-false value.
(defun true? (obj) (if obj true false))												(defun true? (obj) (if obj true false))
(defun false? (obj) (eq obj false))												(defun false? (obj) (eq obj false))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; List manipulation.														;;; List manipulation.

;; REPL - Replace first occurrence.  FUNC is called on each item of LIST in							;; REPL - Replace first occurrence.  FUNC is called on each item of LIST in
;; succession until it returns non-NIL, at which point a new list is								;; succession until it returns non-NIL, at which point a new list is
;; returned in which the guilty item is replaced by the value which was								;; returned in which the guilty item is replaced by the value which was
;; returned by FUNC.  The new list shares its tail with the old.  If FUNC							;; returned by FUNC.  The new list shares its tail with the old.  If FUNC
;; never returns non-nil then a copy of LIST is returned.									;; never returns non-nil then a copy of LIST is returned.
(defun repl (list func)														(defun repl (list func)
  (if list															  (if list
      (let ((v (funcall func (car list))))											      (let ((v (funcall func (car list))))
	(if v (cons v (cdr list))													(if v (cons v (cdr list))
	  (cons (car list) (repl (cdr list) func))))))											  (cons (car list) (repl (cdr list) func))))))

;; In this version of REPL, FUNC is passed not only each item of LIST,								;; In this version of REPL, FUNC is passed not only each item of LIST,
;; but also the item's index (as per NTH or ELT).										;; but also the item's index (as per NTH or ELT).
(defun repl2 (list func &optional (firstindex 0))										(defun repl2 (list func &optional (firstindex 0))
  (labels															  (labels
      ((helper (list index func)												      ((helper (list index func)
	  (if list															  (if list
	      (let ((v (funcall func (car list) index)))										      (let ((v (funcall func (car list) index)))
		(if v (cons v (cdr list))													(if v (cons v (cdr list))
		  (cons (car list) (helper (cdr list) (1+ index) func)))))))									  (cons (car list) (helper (cdr list) (1+ index) func)))))))
    (helper list firstindex func)))												    (helper list firstindex func)))

diff -ryw '--width=260' '--exclude=README.*' ../src/variables.lisp ../src2/variables.lisp
;;; -*- Package: user -*-													;;; -*- Package: user -*-
(in-package "USER")														(in-package "USER")
;;; ----------------------------------------------------------------------							;;; ----------------------------------------------------------------------
;;; Constructs for variable-environment manipulation (creating/destroying							;;; Constructs for variable-environment manipulation (creating/destroying
;;; variables, changing their locations, etc.)											;;; variables, changing their locations, etc.)
;;; ----------------------------------------------------------------------							;;; ----------------------------------------------------------------------

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; User-level constructs.													;;; User-level constructs.

;; Create a new variable VAR, bind it to VAL, execute the BODY, and then							;; Create a new variable VAR, bind it to VAL, execute the BODY, and then
;; unbind it from VAL and get rid of it.  VAL may be an expression, but it							;; unbind it from VAL and get rid of it.  VAL may be an expression, but it
;; must evaluate to whatever value VAR actually has at the end of the BODY,							;; must evaluate to whatever value VAR actually has at the end of the BODY,
;; or else all bets are off!													;; or else all bets are off!
;;																;;
;; 6/3/97 - Now LET is slightly more general---VAR can be put into a								;; 6/3/97 - Now LET is slightly more general---VAR can be put into a
;; relationship with VAL in any of a number of ways... <-, <->, ^=, +=...							;; relationship with VAL in any of a number of ways... <-, <->, ^=, +=...
;; <-, ^=, += are all equivalent given that SCOPE forces VAR to initially							;; <-, ^=, += are all equivalent given that SCOPE forces VAR to initially
;; be zero, but <-> is different... It sets VAR by swapping it with VAL,							;; be zero, but <-> is different... It sets VAR by swapping it with VAL,
;; which obviously must be a location of some sort.  Afterwards VAR is								;; which obviously must be a location of some sort.  Afterwards VAR is
;; restored to zero by swapping it back.  Note that in this case, if VAR is							;; restored to zero by swapping it back.  Note that in this case, if VAR is
;; not left at zero by the BODY, this is fine and results in VAL being								;; not left at zero by the BODY, this is fine and results in VAL being
;; side-effected.  In other words, this kind of LET is effectively								;; side-effected.  In other words, this kind of LET is effectively
;; temporarily giving VAL a new name which pulls it into a register if say							;; temporarily giving VAL a new name which pulls it into a register if say
;; it was originally an array entry.  Another kind of operation (not yet							;; it was originally an array entry.  Another kind of operation (not yet
;; defined) would have VAL be a variable and assign VAR to be truly a								;; defined) would have VAL be a variable and assign VAR to be truly a
;; synonym for that exact same variable.											;; synonym for that exact same variable.

(defconstruct let ((var ~ val) &body body)											(defconstruct let ((var ~ val) &body body)
  (if (eq ~ '<-)														  (if (eq ~ '<-)
      `(scope ,var														      `(scope ,var
	  (_with (,var <- ,val)														  (_with (,var <- ,val)
		 . ,body))															 . ,body))
    `(scope ,var														    `(scope ,var
	(with (,var ,~ ,val)														(with (,var ,~ ,val)
	      . ,body))))														      . ,body))))

;; Declare some vars that should be allocated register locations as soon							;; Declare some vars that should be allocated register locations as soon
;; as they are created.														;; as they are created.
(defconstruct with-regvars (var-or-vars &body body)										(defconstruct with-regvars (var-or-vars &body body)
  `(scope ,var-or-vars														  `(scope ,var-or-vars
     (register ,var-or-vars)													     (register ,var-or-vars)
     . ,body))															     . ,body))

;; User-level hint to compiler: put the following variables in registers							;; User-level hint to compiler: put the following variables in registers
;; now rather than later.													;; now rather than later.
(defconstruct register (var-or-vars)												(defconstruct register (var-or-vars)
  (let ((varlist (if (listp var-or-vars) var-or-vars (list var-or-vars))))							  (let ((varlist (if (listp var-or-vars) var-or-vars (list var-or-vars))))
    (mapcar #'(lambda (var) `(get-in-register ,var)) varlist)))									    (mapcar #'(lambda (var) `(get-in-register ,var)) varlist)))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Intermediate-level constructs.  Not recommended for casual users.								;;; Intermediate-level constructs.  Not recommended for casual users.

(defconstruct with-location-map (locmapdesc &body body)										(defconstruct with-location-map (locmapdesc &body body)
  `((locmap ,locmapdesc)													  `((locmap ,locmapdesc)
    ,@body															    ,@body
    (locmap ,locmapdesc)))													    (locmap ,locmapdesc)))

;; WITH-ENVIRONMENT envdesc body - Ensure that the environment, as far as							;; WITH-ENVIRONMENT envdesc body - Ensure that the environment, as far as
;; location maps go, is equivalent to the one specified by environment								;; location maps go, is equivalent to the one specified by environment
;; description ENVDESC, both at the beginning and at the end of the body.							;; description ENVDESC, both at the beginning and at the end of the body.
(defconstruct with-environment (envdesc &body body)										(defconstruct with-environment (envdesc &body body)
  `((environment ,envdesc)													  `((environment ,envdesc)
    ,@body															    ,@body
    (environment ,envdesc)))													    (environment ,envdesc)))

;; ENVIRONMENT envdesc - Ensure that the environment is equivalent to the							;; ENVIRONMENT envdesc - Ensure that the environment is equivalent to the
;; one specified by environment description ENVDESC.  ENVDESC must describe							;; one specified by environment description ENVDESC.  ENVDESC must describe
;; an environment object.  Currently the only supported kind of description							;; an environment object.  Currently the only supported kind of description
;; is an environment object itself.  Environments are equivalent if they							;; is an environment object itself.  Environments are equivalent if they
;; have the same variables in the same locations.  ENVIRONMENT will move							;; have the same variables in the same locations.  ENVIRONMENT will move
;; variables around as necessary to make the environments match, but it								;; variables around as necessary to make the environments match, but it
;; will not create or destroy any variables.  If the environments cannot be							;; will not create or destroy any variables.  If the environments cannot be
;; made to match, currently a compiler error is generated.									;; made to match, currently a compiler error is generated.
(defconstruct environment (envdesc)												(defconstruct environment (envdesc)
  (if (equal-env? env envdesc)													  (if (equal-env? env envdesc)
      (values '() envdesc)  ;Tell RCOMP the requested form of the description.							      (values '() envdesc)  ;Tell RCOMP the requested form of the description.
    (if (equal-vars? env envdesc)	;Do the envs have the same variables?							    (if (equal-vars? env envdesc)	;Do the envs have the same variables?
	;; Relocate the first mis-located variable, and try again.									;; Relocate the first mis-located variable, and try again.
	(let ((v (first-misloc env envdesc)))												(let ((v (first-misloc env envdesc)))
	  (if (null (location v envdesc))												  (if (null (location v envdesc))
	      `(environment ,(set-loc v (location v env) envdesc))									      `(environment ,(set-loc v (location v env) envdesc))
	    `((relocate ,v ,(location v envdesc))											    `((relocate ,v ,(location v envdesc))
	      (environment ,envdesc))))													      (environment ,envdesc))))
      (error "Environments ~s and ~s don't match." env envdesc))))								      (error "Environments ~s and ~s don't match." env envdesc))))

(defconstruct locmap (locmapdesc)												(defconstruct locmap (locmapdesc)
  (setf env2 (copy-environment env)												  (setf env2 (copy-environment env)
	(locmap env2) locmapdesc)													(locmap env2) locmapdesc)
  `(environment ,env2))														  `(environment ,env2))

(defconstruct declare-locmap (locmapdesc)											(defconstruct declare-locmap (locmapdesc)
  (setf env (copy-environment env)												  (setf env (copy-environment env)
	(locmap env) locmapdesc)													(locmap env) locmapdesc)
  (values nil env))														  (values nil env))

(defconstruct declare-environment (envdesc)											(defconstruct declare-environment (envdesc)
  (setf env (copy-environment envdesc))												  (setf env (copy-environment envdesc))
  (values nil env))														  (values nil env))

;; The given variable should exist throughout the body of the scope, no								;; The given variable should exist throughout the body of the scope, no
;; more, no less.  The body must leave the variable clear, or else!								;; more, no less.  The body must leave the variable clear, or else!
(defconstruct scope (var &body body)												(defconstruct scope (var &body body)
  (let ((vlist (if (listp var) var (list var))))										  (let ((vlist (if (listp var) var (list var))))
    `(with ,(mapcar #'(lambda (var) `(add-to-env ,var)) vlist)									    `(with ,(mapcar #'(lambda (var) `(add-to-env ,var)) vlist)
	   ,@body))															   ,@body))
  ;; Note danger if var is not actually clear at end of BODY!									  ;; Note danger if var is not actually clear at end of BODY!
  )																  )

;; ENSURE-GREEN enforces environmental correctness -- it leaves the								;; ENSURE-GREEN enforces environmental correctness -- it leaves the
;; environment just the way it found it. (With regards to its location map.)							;; environment just the way it found it. (With regards to its location map.)
(defconstruct ensure-green (&body body)												(defconstruct ensure-green (&body body)
  `(,@body															  `(,@body
    (locmap ,(locmap env))))													    (locmap ,(locmap env))))

;; DECLARE-GREEN declares that the environment in effect when the body								;; DECLARE-GREEN declares that the environment in effect when the body
;; is entered will necessarily be in effect when it ends.  Don't use this							;; is entered will necessarily be in effect when it ends.  Don't use this
;; when it isn't true!														;; when it isn't true!
(defconstruct declare-green (&body body)											(defconstruct declare-green (&body body)
  (values body env))														  (values body env))

;; Make the LOCATION be clear, and associate it with a new variable VARNAME.							;; Make the LOCATION be clear, and associate it with a new variable VARNAME.
(defconstruct new-var-at (varname location)											(defconstruct new-var-at (varname location)
  (if (defined-in-env? varname env)												  (if (defined-in-env? varname env)
      (error "Variable ~s is already in the environment!" varname)								      (error "Variable ~s is already in the environment!" varname)
    `((vacate ,location)													    `((vacate ,location)
      (tell-loc ,varname ,location))))												      (tell-loc ,varname ,location))))

;; Make a particular location LOC become available (empty, and no variable							;; Make a particular location LOC become available (empty, and no variable
;; assigned to it).														;; assigned to it).
(defconstruct vacate (loc)													(defconstruct vacate (loc)
  (let ((v (var-at-loc loc env)))												  (let ((v (var-at-loc loc env)))
    (if v															    (if v
	;; Location is occupied by variable V.												;; Location is occupied by variable V.
	(let ((reg (next-avail-reg env)))												(let ((reg (next-avail-reg env)))
	  ;; If any registers are available, move V there.										  ;; If any registers are available, move V there.
	  (if reg `(relocate ,v ,reg)													  (if reg `(relocate ,v ,reg)
	    ;; Else move V to the next available stack location.									    ;; Else move V to the next available stack location.
	    (let ((s (next-avail-stack env)))												    (let ((s (next-avail-stack env)))
	      (if s `(relocate ,v ,s))))))))												      (if s `(relocate ,v ,s))))))))

;; Arrange for the given variable, which should already be present in the							;; Arrange for the given variable, which should already be present in the
;; environment, to be located in a register (instead of on the stack).								;; environment, to be located in a register (instead of on the stack).
(defconstruct get-in-register (var)												(defconstruct get-in-register (var)
  (if (symbolp var)														  (if (symbolp var)
      (let ((l (location var env)))												      (let ((l (location var env)))
	(if (not (register? l))		;If it's not already in a register,								(if (not (register? l))		;If it's not already in a register,
	    (let ((reg (next-avail-reg env)))												    (let ((reg (next-avail-reg env)))
	      (if reg	    ;If there is a register avaiable, put it there.								      (if reg	    ;If there is a register avaiable, put it there.
		  (if (null-loc? l)														  (if (null-loc? l)
		      `(tell-loc ,var ,reg)													      `(tell-loc ,var ,reg)
		    `(relocate ,var ,reg))													    `(relocate ,var ,reg))
		;; Else boot out the least-recently moved variable.										;; Else boot out the least-recently moved variable.
		(let* ((victim (least-recently-moved env))											(let* ((victim (least-recently-moved env))
		       (loc (location victim env)))												       (loc (location victim env)))
		  (if (null-loc? l)														  (if (null-loc? l)
		      `((vacate ,loc)														      `((vacate ,loc)
			(tell-loc ,var ,loc))														(tell-loc ,var ,loc))
		    `(relocate ,var ,loc)))))))))												    `(relocate ,var ,loc)))))))))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Primitive environment-manipulation constructs.										;;; Primitive environment-manipulation constructs.

;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::							;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;; ADD-TO-ENV: Create the given variable in the environment, but don't								;; ADD-TO-ENV: Create the given variable in the environment, but don't
;; give it a location quite yet.												;; give it a location quite yet.
;;																;;
;; Semantics amendment, 8/4/01 - Actually, not giving every new									;; Semantics amendment, 8/4/01 - Actually, not giving every new
;; variable a location right away turns out be dangerous, because the								;; variable a location right away turns out be dangerous, because the
;; first manipulation of the variable might be within an ensure-green								;; first manipulation of the variable might be within an ensure-green
;; context, so the variable's location will be forgotten.  (Actually,								;; context, so the variable's location will be forgotten.  (Actually,
;; in the present version this elicits an infinite loop.)  So, we're								;; in the present version this elicits an infinite loop.)  So, we're
;; changing the semantics of ADD-TO-ENV to go ahead and assign the								;; changing the semantics of ADD-TO-ENV to go ahead and assign the
;; variable to a register.													;; variable to a register.
;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::							;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
(defconstruct add-to-env (var) :opposite remove-var										(defconstruct add-to-env (var) :opposite remove-var
  `((_add-to-env ,var)														  `((_add-to-env ,var)
    (get-in-register ,var)))													    (get-in-register ,var)))

;; _ADD-TO-ENV - Like ADD-TO-ENV, but really doesn't give the									;; _ADD-TO-ENV - Like ADD-TO-ENV, but really doesn't give the
;; variable a location yet.  Don't ever use this except the way									;; variable a location yet.  Don't ever use this except the way
;; it's used in ADD-TO-ENV!!													;; it's used in ADD-TO-ENV!!

(defconstruct _add-to-env (var)													(defconstruct _add-to-env (var)
  (if (defined-in-env? var env)													  (if (defined-in-env? var env)
      (error "Variable ~s already exists!" var)											      (error "Variable ~s already exists!" var)
    (values '() (set-loc var nil env))))											    (values '() (set-loc var nil env))))

;; Change the current environment to have the location of variable VAR as							;; Change the current environment to have the location of variable VAR as
;; being LOC.  Generates no code.  This construct is dangerous if the old							;; being LOC.  Generates no code.  This construct is dangerous if the old
;; location of VAR has a non-zero runtime value, and is not associated with							;; location of VAR has a non-zero runtime value, and is not associated with
;; any other variable.														;; any other variable.
(defconstruct tell-loc (var loc)												(defconstruct tell-loc (var loc)
  (values '() (set-loc var loc env)))												  (values '() (set-loc var loc env)))

;; Assuming that a variable is empty, remove it from the environment!								;; Assuming that a variable is empty, remove it from the environment!
;; (Danger, Will Robinson!)  This causes grave problems if the runtime								;; (Danger, Will Robinson!)  This causes grave problems if the runtime
;; value of the variable is not zero.  But currently we generate no runtime							;; value of the variable is not zero.  But currently we generate no runtime
;; code to notice that condition, so watch out!											;; code to notice that condition, so watch out!
(defconstruct remove-var (varname) :opposite add-to-env										(defconstruct remove-var (varname) :opposite add-to-env
  (values '() (remove-var varname env)))											  (values '() (remove-var varname env)))

;;;----------------------------------------------------------------------							;;;----------------------------------------------------------------------
;;; Low-level utilities for working with variables.										;;; Low-level utilities for working with variables.

(defun variable? (form) (symbolp form))												(defun variable? (form) (symbolp form))
